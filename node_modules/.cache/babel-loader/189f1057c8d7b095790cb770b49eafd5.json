{"ast":null,"code":"'use strict';\n\n/**\r\n * Module dependencies\r\n */\nconst EventEmitter = require('events').EventEmitter;\nconst Store = require('./store');\nconst TopicAliasRecv = require('./topic-alias-recv');\nconst TopicAliasSend = require('./topic-alias-send');\nconst mqttPacket = require('mqtt-packet');\nconst DefaultMessageIdProvider = require('./default-message-id-provider');\nconst Writable = require('readable-stream').Writable;\nconst inherits = require('inherits');\nconst reInterval = require('reinterval');\nconst clone = require('rfdc/default');\nconst validations = require('./validations');\nconst xtend = require('xtend');\nconst debug = require('debug')('mqttjs:client');\nconst nextTick = process ? process.nextTick : function (callback) {\n  setTimeout(callback, 0);\n};\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback);\n};\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\nfunction applyTopicAlias(client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias;\n      if (packet.properties) {\n        alias = packet.properties.topicAlias;\n      }\n      const topic = packet.topic.toString();\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n              return new Error('Sending Topic Alias out of range');\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);\n              } else {\n                alias = client.topicAliasSend.getLruAlias();\n                client.topicAliasSend.put(topic, alias);\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n        return new Error('Sending Topic Alias out of range');\n      }\n    }\n  }\n}\nfunction removeTopicAliasAndRecoverTopicName(client, packet) {\n  let alias;\n  if (packet.properties) {\n    alias = packet.properties.topicAlias;\n  }\n  let topic = packet.topic.toString();\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias');\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias);\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      } else {\n        packet.topic = topic;\n      }\n    }\n  }\n  if (alias) {\n    delete packet.properties.topicAlias;\n  }\n}\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  let storePacket = packet;\n  let err;\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket);\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n  client.outgoingStore.put(storePacket, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\nfunction nop(error) {\n  debug('nop ::', error);\n}\n\n/**\r\n * MqttClient constructor\r\n *\r\n * @param {Stream} stream - stream\r\n * @param {Object} [options] - connection options\r\n * (see Connection#connect)\r\n */\nfunction MqttClient(streamBuilder, options) {\n  let k;\n  const that = this;\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n  this.options = options || {};\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder;\n  this.messageIdProvider = typeof this.options.messageIdProvider === 'undefined' ? new DefaultMessageIdProvider() : this.options.messageIdProvider;\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store();\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {};\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {};\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null;\n  // Is the client connected?\n  this.connected = false;\n  // Are we disconnecting?\n  this.disconnecting = false;\n  // Packet queue\n  this.queue = [];\n  // connack timer\n  this.connackTimer = null;\n  // Reconnect timer\n  this.reconnectTimer = null;\n  // Is processing store?\n  this._storeProcessing = false;\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {};\n  // Store processing queue\n  this._storeProcessingQueue = [];\n\n  // Inflight callbacks\n  this.outgoing = {};\n\n  // True if connection is first time.\n  this._firstConnection = true;\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range');\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);\n    }\n  }\n\n  // Send queued packets\n  this.on('connect', function () {\n    const queue = this.queue;\n    function deliver() {\n      const entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      let packet = null;\n      if (!entry) {\n        that._resubscribe();\n        return;\n      }\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n      let send = true;\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false;\n        }\n      }\n      if (send) {\n        that._sendPacket(packet, function (err) {\n          if (entry.cb) {\n            entry.cb(err);\n          }\n          deliver();\n        });\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId);\n        deliver();\n      }\n    }\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear();\n    }\n    debug('close :: calling _setupReconnect');\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n  this._setupStream();\n}\ninherits(MqttClient, EventEmitter);\n\n/**\r\n * setup the event handlers in the inner stream.\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._setupStream = function () {\n  const that = this;\n  const writable = new Writable();\n  const parser = mqttPacket.parser(this.options);\n  let completeParse = null;\n  const packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n  this._clearReconnect();\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n  function nextTickWork() {\n    if (packets.length) {\n      nextTick(work);\n    } else {\n      const done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n  function work() {\n    debug('work :: getting next packet in queue');\n    const packet = packets.shift();\n    if (packet) {\n      debug('work :: packet pulled from queue');\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      const done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n    // error.code will only be set on NodeJS env, browse don't allow to detect erros on sockets\n    // also emitting errors on browser seems to create issues \n    if (error.code) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable);\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler);\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  });\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`');\n  const connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {};\n    }\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;\n    }\n  }\n  // avoid message queue\n  sendPacket(this, connectPacket);\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'));\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options;\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n      done();\n      break;\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n      break;\n    case 'connack':\n      this._handleConnack(packet);\n      done();\n      break;\n    case 'auth':\n      this._handleAuth(packet);\n      done();\n      break;\n    case 'pingresp':\n      this._handlePingresp(packet);\n      done();\n      break;\n    case 'disconnect':\n      this._handleDisconnect(packet);\n      done();\n      break;\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n  return this.disconnecting;\n};\n\n/**\r\n * publish - publish <message> to <topic>\r\n *\r\n * @param {String} topic - topic to publish to\r\n * @param {String, Buffer} message - message to publish\r\n * @param {Object} [opts] - publish options, includes:\r\n *    {Number} qos - qos level to publish on\r\n *    {Boolean} retain - whether or not to retain the message\r\n *    {Boolean} dup - whether or not mark a message as duplicate\r\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\r\n * @param {Function} [callback] - function(err){}\r\n *    called when publish succeeds or fails\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.publish('topic', 'message');\r\n * @example\r\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\r\n * @example client.publish('topic', 'message', console.log);\r\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  const options = this.options;\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  // default opts\n  const defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  const that = this;\n  const publishProc = function () {\n    let messageId = 0;\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId();\n      if (messageId === null) {\n        debug('No messageId left');\n        return false;\n      }\n    }\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    };\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties;\n    }\n    debug('publish :: qos', opts.qos);\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        };\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        that._sendPacket(packet, undefined, opts.cbStorePut);\n        break;\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        that._sendPacket(packet, callback, opts.cbStorePut);\n        break;\n    }\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push({\n      invoke: publishProc,\n      cbStorePut: opts.cbStorePut,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\r\n * subscribe - subscribe to <topic>\r\n *\r\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Number} qos - subscribe qos level\r\n * @param {Function} [callback] - function(err, granted){} where:\r\n *    {Error} err - subscription error (none at the moment!)\r\n *    {Array} granted - array of {topic: 't', qos: 0}\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.subscribe('topic');\r\n * @example client.subscribe('topic', {qos: 1});\r\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\r\n * @example client.subscribe('topic', console.log);\r\n */\nMqttClient.prototype.subscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  const subs = [];\n  let obj = args.shift();\n  const resubscribe = obj.resubscribe;\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  const version = this.options.protocolVersion;\n  delete obj.resubscribe;\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  const invalidTopic = validations.validateTopics(obj);\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n  const defaultOpts = {\n    qos: 0\n  };\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n  opts = xtend(defaultOpts, opts);\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        const currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n  if (!subs.length) {\n    callback(null, []);\n    return this;\n  }\n  const subscribeProc = function () {\n    const messageId = that._nextId();\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    };\n    if (opts.properties) {\n      packet.properties = opts.properties;\n    }\n\n    // subscriptions to resubscribe to in case of disconnect\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true');\n      const topics = [];\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = {\n            qos: sub.qos\n          };\n          if (version === 5) {\n            topic.nl = sub.nl || false;\n            topic.rap = sub.rap || false;\n            topic.rh = sub.rh || 0;\n            topic.properties = sub.properties;\n          }\n          that._resubscribeTopics[sub.topic] = topic;\n          topics.push(sub.topic);\n        }\n      });\n      that.messageIdToTopic[packet.messageId] = topics;\n    }\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted;\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i];\n          }\n        }\n        callback(err, subs);\n      }\n    };\n    debug('subscribe :: call _sendPacket');\n    that._sendPacket(packet);\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: subscribeProc,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\r\n * unsubscribe - unsubscribe from topic(s)\r\n *\r\n * @param {String, Array} topic - topics to unsubscribe from\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Object} properties - properties of unsubscribe packet\r\n * @param {Function} [callback] - callback fired on unsuback\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.unsubscribe('topic');\r\n * @example client.unsubscribe('topic', console.log);\r\n */\nMqttClient.prototype.unsubscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  let topic = args.shift();\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  const invalidTopic = validations.validateTopics(topic);\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n  if (that._checkDisconnecting(callback)) {\n    return this;\n  }\n  const unsubscribeProc = function () {\n    const messageId = that._nextId();\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    };\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic];\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic;\n    }\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic];\n      });\n    }\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties;\n    }\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    };\n    debug('unsubscribe: call _sendPacket');\n    that._sendPacket(packet);\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: unsubscribeProc,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\r\n * end - close connection\r\n *\r\n * @returns {MqttClient} this - for chaining\r\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n * @param {Object} opts - added to the disconnect packet\r\n * @param {Function} cb - called when the client has been closed\r\n *\r\n * @api public\r\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this;\n  debug('end :: (%s)', this.options.clientId);\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n        if (cb) {\n          const err = e1 || e2;\n          debug('end :: closeStores: invoking callback with args');\n          cb(err);\n        }\n      });\n    });\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores');\n      // const boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that));\n    }, opts);\n  }\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n  this._clearReconnect();\n  this.disconnecting = true;\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n  return this;\n};\n\n/**\r\n * removeOutgoingMessage - remove a message in outgoing store\r\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n *\r\n * @param {Number} messageId - messageId to remove message\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.removeOutgoingMessage(client.getLastAllocated());\r\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n\n/**\r\n * reconnect - connect again using the same options as connect()\r\n *\r\n * @param {Object} [opts] - optional reconnect options, includes:\r\n *    {Store} incomingStore - a store for the incoming packets\r\n *    {Store} outgoingStore - a store for the outgoing packets\r\n *    if opts is not given, current stores are used\r\n * @returns {MqttClient} this - for chaining\r\n *\r\n * @api public\r\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  const that = this;\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n    that._reconnect();\n  };\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n  return this;\n};\n\n/**\r\n * _reconnect - implement reconnection\r\n * @api privateish\r\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n  if (this.connected) {\n    this.end(() => {\n      this._setupStream();\n    });\n    debug('client already connected. disconnecting first.');\n  } else {\n    debug('_reconnect: calling _setupStream');\n    this._setupStream();\n  }\n};\n\n/**\r\n * _setupReconnect - setup reconnect timer\r\n */\nMqttClient.prototype._setupReconnect = function () {\n  const that = this;\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n\n/**\r\n * _clearReconnect - clear the reconnect timer\r\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n\n/**\r\n * _cleanUp - clean up on connection end\r\n * @api private\r\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2];\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n  debug('_cleanUp :: forced? %s', forced);\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    const packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n    this._clearReconnect();\n    this._setupReconnect();\n  }\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n\n/**\r\n * _sendPacket - send or queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n  cb = cb || nop;\n  const err = applyTopicAlias(this, packet);\n  if (err) {\n    cb(err);\n    return;\n  }\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval();\n      sendPacket(this, packet, cb);\n      return;\n    }\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n    this._storePacket(packet, cb, cbStorePut);\n    return;\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval();\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n    /**\r\n     * no need of case here since it will be caught by default\r\n     * and jshint comply that before default it must be a break\r\n     * anyway it will result in -1 evaluation\r\n     */\n    case 0:\n    /* falls through */\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n\n/**\r\n * _storePacket - queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop;\n  let storePacket = packet;\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket);\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== 'publish') {\n    this.queue.push({\n      packet: storePacket,\n      cb: cb\n    });\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n\n/**\r\n * _setupPingTimer - setup the ping timer\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  const that = this;\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n\n/**\r\n * _shiftPingInterval - reschedule the ping interval\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\r\n * _checkPing - check if a pingresp has come back, and ping the server again\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n    this._cleanUp(true);\n  }\n};\n\n/**\r\n * _handlePingresp - handle a pingresp\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n\n/**\r\n * _handleConnack\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n  delete this.topicAliasSend;\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'));\n        return;\n      }\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);\n      }\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n      this._shiftPingInterval();\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n  if (rc === 0) {\n    this.reconnecting = false;\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version);\n    err.code = rc;\n    this.emit('error', err);\n    return;\n  }\n  const that = this;\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err);\n      return;\n    }\n    if (rc === 24) {\n      that.reconnecting = false;\n      that._sendPacket(packet);\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc]);\n      err.code = rc;\n      that.emit('error', error);\n    }\n  });\n};\n\n/**\r\n * @param packet the packet received by the broker\r\n * @return the auth packet to be returned to the broker\r\n * @api public\r\n */\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback();\n};\n\n/**\r\n * _handlePublish\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n/*\r\nthose late 2 case should be rewrite to comply with coding style:\r\n\r\ncase 1:\r\ncase 0:\r\n  // do not wait sending a puback\r\n  // no callback passed\r\n  if (1 === qos) {\r\n    this._sendPacket({\r\n      cmd: 'puback',\r\n      messageId: messageId\r\n    });\r\n  }\r\n  // emit the message event for both qos 1 and 0\r\n  this.emit('message', topic, message, packet);\r\n  this.handleMessage(packet, done);\r\n  break;\r\ndefault:\r\n  // do nothing but every switch mus have a default\r\n  // log or throw an error about unknown qos\r\n  break;\r\n\r\nfor now i just suppressed the warnings\r\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  let topic = packet.topic.toString();\n  const message = packet.payload;\n  const qos = packet.qos;\n  const messageId = packet.messageId;\n  const that = this;\n  const options = this.options;\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n  if (this.options.protocolVersion === 5) {\n    let alias;\n    if (packet.properties) {\n      alias = packet.properties.topicAlias;\n    }\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);\n          if (gotTopic) {\n            topic = gotTopic;\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias);\n            this.emit('error', new Error('Received unregistered Topic Alias'));\n            return;\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias);\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      }\n    }\n  }\n  debug('_handlePublish: qos %d', qos);\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.');\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n\n/**\r\n * Handle messages with backpressure support, one at a time.\r\n * Override at will.\r\n *\r\n * @param Packet packet the packet\r\n * @param Function callback call when finished\r\n * @api public\r\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n\n/**\r\n * _handleAck\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId;\n  const type = packet.cmd;\n  let response = null;\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  const that = this;\n  let err;\n\n  // Checking `!cb` happens to work, but it's not technically \"correct\".\n  //\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\n  //\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\n  // there's no reason to change it and risk (another) regression.\n  //\n  // The only reason this code works is becaues code in MqttClient.publish,\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\n  // have a callback even if the user doesn't pass one in.)\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.');\n    // Server sent an ack in error, ignore it.\n    return;\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type);\n  switch (type) {\n    case 'pubcomp':\n    // same thing as puback for QoS 2\n    case 'puback':\n      {\n        const pubackRC = packet.reasonCode;\n        // Callback - we're done\n        if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubackRC]);\n          err.code = pubackRC;\n          cb(err, packet);\n        }\n        delete this.outgoing[messageId];\n        this.outgoingStore.del(packet, cb);\n        this.messageIdProvider.deallocate(messageId);\n        this._invokeStoreProcessingQueue();\n        break;\n      }\n    case 'pubrec':\n      {\n        response = {\n          cmd: 'pubrel',\n          qos: 2,\n          messageId: messageId\n        };\n        const pubrecRC = packet.reasonCode;\n        if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubrecRC]);\n          err.code = pubrecRC;\n          cb(err, packet);\n        } else {\n          this._sendPacket(response);\n        }\n        break;\n      }\n    case 'suback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n        for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n          if ((packet.granted[grantedI] & 0x80) !== 0) {\n            // suback with Failure status\n            const topics = this.messageIdToTopic[messageId];\n            if (topics) {\n              topics.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n          }\n        }\n        this._invokeStoreProcessingQueue();\n        cb(null, packet);\n        break;\n      }\n    case 'unsuback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n        this._invokeStoreProcessingQueue();\n        cb(null);\n        break;\n      }\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n\n/**\r\n * _handlePubrel\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  const messageId = packet.messageId;\n  const that = this;\n  const comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        that.incomingStore.del(pub, nop);\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n\n/**\r\n * _handleDisconnect\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n\n/**\r\n * _nextId\r\n * @return unsigned int\r\n */\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate();\n};\n\n/**\r\n * getLastMessageId\r\n * @return unsigned int\r\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated();\n};\n\n/**\r\n * _resubscribe\r\n * @api private\r\n */\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe');\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n  this._firstConnection = false;\n};\n\n/**\r\n * _onConnect\r\n *\r\n * @api private\r\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n  const that = this;\n  this.connackPacket = packet;\n  this.messageIdProvider.clear();\n  this._setupPingTimer();\n  this.connected = true;\n  function startStreamProcess() {\n    let outStore = that.outgoingStore.createStream();\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n      that._flushStoreProcessingQueue();\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n      that._flushStoreProcessingQueue();\n      clearStoreProcessing();\n    }\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n      that._storeProcessing = true;\n      const packet = outStore.read(1);\n      let cb;\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet);\n        } else {\n          debug('messageId: %d has already used.', packet.messageId);\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n    outStore.on('end', function () {\n      let allProcessed = true;\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n        that._invokeAllStoreProcessingQueue();\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  }\n  // start flowing\n  startStreamProcess();\n};\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0];\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift();\n      return true;\n    }\n  }\n  return false;\n};\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) {/* empty */}\n};\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'));\n    if (f.callback) f.callback(new Error('Connection closed'));\n  }\n  this._storeProcessingQueue.splice(0);\n};\nmodule.exports = MqttClient;","map":{"version":3,"names":["EventEmitter","require","Store","TopicAliasRecv","TopicAliasSend","mqttPacket","DefaultMessageIdProvider","Writable","inherits","reInterval","clone","validations","xtend","debug","nextTick","process","callback","setTimeout","setImmediate","global","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","errors","defaultId","Math","random","toString","substr","applyTopicAlias","client","packet","options","cmd","alias","properties","topicAlias","topic","topicAliasSend","length","put","Error","autoAssignTopicAlias","getAliasByTopic","getLruAlias","autoUseTopicAlias","removeTopicAliasAndRecoverTopicName","getTopicByAlias","sendPacket","cb","emit","result","writeToStream","stream","nop","once","flush","queue","Object","keys","forEach","messageId","flushVolatile","volatile","storeAndSend","cbStorePut","storePacket","err","outgoingStore","storedPacket","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","topicAliasMaximum","clientId","customHandleAcks","arguments","messageIdProvider","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","_storeProcessingQueue","outgoing","_firstConnection","topicAliasRecv","on","deliver","entry","shift","_resubscribe","send","register","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","code","pipe","connectPacket","create","max","bind","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handleAuth","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","opts","defaultOpts","qos","retain","dup","publishProc","_nextId","payload","invoke","subscribe","args","Array","i","subs","obj","pop","version","invalidTopic","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscribeProc","subscriptions","topics","sub","granted","unsubscribe","unsubscribeProc","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_storePacket","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","handleAuth","validReasonCodes","gotTopic","indexOf","handleMessage","type","response","pubackRC","deallocate","_invokeStoreProcessingQueue","pubrecRC","grantedI","comp","get","pub","allocate","getLastMessageId","getLastAllocated","_resubscribeTopicsKeys","connackPacket","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","_flushStoreProcessingQueue","storeDeliver","read","status","allProcessed","id","_invokeAllStoreProcessingQueue","splice","module","exports"],"sources":["C:/Documents/warehouse-dashboard/node_modules/mqtt/lib/client.js"],"sourcesContent":["'use strict'\r\n\r\n/**\r\n * Module dependencies\r\n */\r\nconst EventEmitter = require('events').EventEmitter\r\nconst Store = require('./store')\r\nconst TopicAliasRecv = require('./topic-alias-recv')\r\nconst TopicAliasSend = require('./topic-alias-send')\r\nconst mqttPacket = require('mqtt-packet')\r\nconst DefaultMessageIdProvider = require('./default-message-id-provider')\r\nconst Writable = require('readable-stream').Writable\r\nconst inherits = require('inherits')\r\nconst reInterval = require('reinterval')\r\nconst clone = require('rfdc/default')\r\nconst validations = require('./validations')\r\nconst xtend = require('xtend')\r\nconst debug = require('debug')('mqttjs:client')\r\nconst nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\r\nconst setImmediate = global.setImmediate || function (callback) {\r\n  // works in node v0.8\r\n  nextTick(callback)\r\n}\r\nconst defaultConnectOptions = {\r\n  keepalive: 60,\r\n  reschedulePings: true,\r\n  protocolId: 'MQTT',\r\n  protocolVersion: 4,\r\n  reconnectPeriod: 1000,\r\n  connectTimeout: 30 * 1000,\r\n  clean: true,\r\n  resubscribe: true\r\n}\r\n\r\n\r\nconst errors = {\r\n  0: '',\r\n  1: 'Unacceptable protocol version',\r\n  2: 'Identifier rejected',\r\n  3: 'Server unavailable',\r\n  4: 'Bad username or password',\r\n  5: 'Not authorized',\r\n  16: 'No matching subscribers',\r\n  17: 'No subscription existed',\r\n  128: 'Unspecified error',\r\n  129: 'Malformed Packet',\r\n  130: 'Protocol Error',\r\n  131: 'Implementation specific error',\r\n  132: 'Unsupported Protocol Version',\r\n  133: 'Client Identifier not valid',\r\n  134: 'Bad User Name or Password',\r\n  135: 'Not authorized',\r\n  136: 'Server unavailable',\r\n  137: 'Server busy',\r\n  138: 'Banned',\r\n  139: 'Server shutting down',\r\n  140: 'Bad authentication method',\r\n  141: 'Keep Alive timeout',\r\n  142: 'Session taken over',\r\n  143: 'Topic Filter invalid',\r\n  144: 'Topic Name invalid',\r\n  145: 'Packet identifier in use',\r\n  146: 'Packet Identifier not found',\r\n  147: 'Receive Maximum exceeded',\r\n  148: 'Topic Alias invalid',\r\n  149: 'Packet too large',\r\n  150: 'Message rate too high',\r\n  151: 'Quota exceeded',\r\n  152: 'Administrative action',\r\n  153: 'Payload format invalid',\r\n  154: 'Retain not supported',\r\n  155: 'QoS not supported',\r\n  156: 'Use another server',\r\n  157: 'Server moved',\r\n  158: 'Shared Subscriptions not supported',\r\n  159: 'Connection rate exceeded',\r\n  160: 'Maximum connect time',\r\n  161: 'Subscription Identifiers not supported',\r\n  162: 'Wildcard Subscriptions not supported'\r\n}\r\n\r\nfunction defaultId () {\r\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\r\n}\r\n\r\nfunction applyTopicAlias (client, packet) {\r\n  if (client.options.protocolVersion === 5) {\r\n    if (packet.cmd === 'publish') {\r\n      let alias\r\n      if (packet.properties) {\r\n        alias = packet.properties.topicAlias\r\n      }\r\n      const topic = packet.topic.toString()\r\n      if (client.topicAliasSend) {\r\n        if (alias) {\r\n          if (topic.length !== 0) {\r\n            // register topic alias\r\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias)\r\n            if (!client.topicAliasSend.put(topic, alias)) {\r\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\r\n              return new Error('Sending Topic Alias out of range')\r\n            }\r\n          }\r\n        } else {\r\n          if (topic.length !== 0) {\r\n            if (client.options.autoAssignTopicAlias) {\r\n              alias = client.topicAliasSend.getAliasByTopic(topic)\r\n              if (alias) {\r\n                packet.topic = ''\r\n                packet.properties = { ...(packet.properties), topicAlias: alias }\r\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias)\r\n              } else {\r\n                alias = client.topicAliasSend.getLruAlias()\r\n                client.topicAliasSend.put(topic, alias)\r\n                packet.properties = { ...(packet.properties), topicAlias: alias }\r\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias)\r\n              }\r\n            } else if (client.options.autoUseTopicAlias) {\r\n              alias = client.topicAliasSend.getAliasByTopic(topic)\r\n              if (alias) {\r\n                packet.topic = ''\r\n                packet.properties = { ...(packet.properties), topicAlias: alias }\r\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else if (alias) {\r\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\r\n        return new Error('Sending Topic Alias out of range')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction removeTopicAliasAndRecoverTopicName (client, packet) {\r\n  let alias\r\n  if (packet.properties) {\r\n    alias = packet.properties.topicAlias\r\n  }\r\n\r\n  let topic = packet.topic.toString()\r\n  if (topic.length === 0) {\r\n    // restore topic from alias\r\n    if (typeof alias === 'undefined') {\r\n      return new Error('Unregistered Topic Alias')\r\n    } else {\r\n      topic = client.topicAliasSend.getTopicByAlias(alias)\r\n      if (typeof topic === 'undefined') {\r\n        return new Error('Unregistered Topic Alias')\r\n      } else {\r\n        packet.topic = topic\r\n      }\r\n    }\r\n  }\r\n  if (alias) {\r\n    delete packet.properties.topicAlias\r\n  }\r\n}\r\n\r\nfunction sendPacket (client, packet, cb) {\r\n  debug('sendPacket :: packet: %O', packet)\r\n  debug('sendPacket :: emitting `packetsend`')\r\n\r\n  client.emit('packetsend', packet)\r\n\r\n  debug('sendPacket :: writing to stream')\r\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options)\r\n  debug('sendPacket :: writeToStream result %s', result)\r\n  if (!result && cb && cb !== nop) {\r\n    debug('sendPacket :: handle events on `drain` once through callback.')\r\n    client.stream.once('drain', cb)\r\n  } else if (cb) {\r\n    debug('sendPacket :: invoking cb')\r\n    cb()\r\n  }\r\n}\r\n\r\nfunction flush (queue) {\r\n  if (queue) {\r\n    debug('flush: queue exists? %b', !!(queue))\r\n    Object.keys(queue).forEach(function (messageId) {\r\n      if (typeof queue[messageId].cb === 'function') {\r\n        queue[messageId].cb(new Error('Connection closed'))\r\n        // This is suspicious.  Why do we only delete this if we have a callbck?\r\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\r\n        delete queue[messageId]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction flushVolatile (queue) {\r\n  if (queue) {\r\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\r\n    Object.keys(queue).forEach(function (messageId) {\r\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\r\n        queue[messageId].cb(new Error('Connection closed'))\r\n        delete queue[messageId]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction storeAndSend (client, packet, cb, cbStorePut) {\r\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\r\n  let storePacket = packet\r\n  let err\r\n  if (storePacket.cmd === 'publish') {\r\n    // The original packet is for sending.\r\n    // The cloned storePacket is for storing to resend on reconnect.\r\n    // Topic Alias must not be used after disconnected.\r\n    storePacket = clone(packet)\r\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket)\r\n    if (err) {\r\n      return cb && cb(err)\r\n    }\r\n  }\r\n  client.outgoingStore.put(storePacket, function storedPacket (err) {\r\n    if (err) {\r\n      return cb && cb(err)\r\n    }\r\n    cbStorePut()\r\n    sendPacket(client, packet, cb)\r\n  })\r\n}\r\n\r\nfunction nop (error) {\r\n  debug('nop ::', error)\r\n}\r\n\r\n/**\r\n * MqttClient constructor\r\n *\r\n * @param {Stream} stream - stream\r\n * @param {Object} [options] - connection options\r\n * (see Connection#connect)\r\n */\r\nfunction MqttClient (streamBuilder, options) {\r\n  let k\r\n  const that = this\r\n\r\n  if (!(this instanceof MqttClient)) {\r\n    return new MqttClient(streamBuilder, options)\r\n  }\r\n\r\n  this.options = options || {}\r\n\r\n  // Defaults\r\n  for (k in defaultConnectOptions) {\r\n    if (typeof this.options[k] === 'undefined') {\r\n      this.options[k] = defaultConnectOptions[k]\r\n    } else {\r\n      this.options[k] = options[k]\r\n    }\r\n  }\r\n\r\n  debug('MqttClient :: options.protocol', options.protocol)\r\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\r\n  debug('MqttClient :: options.username', options.username)\r\n  debug('MqttClient :: options.keepalive', options.keepalive)\r\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\r\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\r\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum)\r\n\r\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\r\n\r\n  debug('MqttClient :: clientId', this.options.clientId)\r\n\r\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\r\n\r\n  this.streamBuilder = streamBuilder\r\n\r\n  this.messageIdProvider = (typeof this.options.messageIdProvider === 'undefined') ? new DefaultMessageIdProvider() : this.options.messageIdProvider\r\n\r\n  // Inflight message storages\r\n  this.outgoingStore = options.outgoingStore || new Store()\r\n  this.incomingStore = options.incomingStore || new Store()\r\n\r\n  // Should QoS zero messages be queued when the connection is broken?\r\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\r\n\r\n  // map of subscribed topics to support reconnection\r\n  this._resubscribeTopics = {}\r\n\r\n  // map of a subscribe messageId and a topic\r\n  this.messageIdToTopic = {}\r\n\r\n  // Ping timer, setup in _setupPingTimer\r\n  this.pingTimer = null\r\n  // Is the client connected?\r\n  this.connected = false\r\n  // Are we disconnecting?\r\n  this.disconnecting = false\r\n  // Packet queue\r\n  this.queue = []\r\n  // connack timer\r\n  this.connackTimer = null\r\n  // Reconnect timer\r\n  this.reconnectTimer = null\r\n  // Is processing store?\r\n  this._storeProcessing = false\r\n  // Packet Ids are put into the store during store processing\r\n  this._packetIdsDuringStoreProcessing = {}\r\n  // Store processing queue\r\n  this._storeProcessingQueue = []\r\n\r\n  // Inflight callbacks\r\n  this.outgoing = {}\r\n\r\n  // True if connection is first time.\r\n  this._firstConnection = true\r\n\r\n  if (options.topicAliasMaximum > 0) {\r\n    if (options.topicAliasMaximum > 0xffff) {\r\n      debug('MqttClient :: options.topicAliasMaximum is out of range')\r\n    } else {\r\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum)\r\n    }\r\n  }\r\n\r\n  // Send queued packets\r\n  this.on('connect', function () {\r\n    const queue = this.queue\r\n\r\n    function deliver () {\r\n      const entry = queue.shift()\r\n      debug('deliver :: entry %o', entry)\r\n      let packet = null\r\n\r\n      if (!entry) {\r\n        that._resubscribe()\r\n        return\r\n      }\r\n\r\n      packet = entry.packet\r\n      debug('deliver :: call _sendPacket for %o', packet)\r\n      let send = true\r\n      if (packet.messageId && packet.messageId !== 0) {\r\n        if (!that.messageIdProvider.register(packet.messageId)) {\r\n          send = false\r\n        }\r\n      }\r\n      if (send) {\r\n        that._sendPacket(\r\n          packet,\r\n          function (err) {\r\n            if (entry.cb) {\r\n              entry.cb(err)\r\n            }\r\n            deliver()\r\n          }\r\n        )\r\n      } else {\r\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId)\r\n        deliver()\r\n      }\r\n    }\r\n\r\n    debug('connect :: sending queued packets')\r\n    deliver()\r\n  })\r\n\r\n  this.on('close', function () {\r\n    debug('close :: connected set to `false`')\r\n    this.connected = false\r\n\r\n    debug('close :: clearing connackTimer')\r\n    clearTimeout(this.connackTimer)\r\n\r\n    debug('close :: clearing ping timer')\r\n    if (that.pingTimer !== null) {\r\n      that.pingTimer.clear()\r\n      that.pingTimer = null\r\n    }\r\n\r\n    if (this.topicAliasRecv) {\r\n      this.topicAliasRecv.clear()\r\n    }\r\n\r\n    debug('close :: calling _setupReconnect')\r\n    this._setupReconnect()\r\n  })\r\n  EventEmitter.call(this)\r\n\r\n  debug('MqttClient :: setting up stream')\r\n  this._setupStream()\r\n}\r\ninherits(MqttClient, EventEmitter)\r\n\r\n/**\r\n * setup the event handlers in the inner stream.\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupStream = function () {\r\n  const that = this\r\n  const writable = new Writable()\r\n  const parser = mqttPacket.parser(this.options)\r\n  let completeParse = null\r\n  const packets = []\r\n\r\n  debug('_setupStream :: calling method to clear reconnect')\r\n  this._clearReconnect()\r\n\r\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\r\n  this.stream = this.streamBuilder(this)\r\n\r\n  parser.on('packet', function (packet) {\r\n    debug('parser :: on packet push to packets array.')\r\n    packets.push(packet)\r\n  })\r\n\r\n  function nextTickWork () {\r\n    if (packets.length) {\r\n      nextTick(work)\r\n    } else {\r\n      const done = completeParse\r\n      completeParse = null\r\n      done()\r\n    }\r\n  }\r\n\r\n  function work () {\r\n    debug('work :: getting next packet in queue')\r\n    const packet = packets.shift()\r\n\r\n    if (packet) {\r\n      debug('work :: packet pulled from queue')\r\n      that._handlePacket(packet, nextTickWork)\r\n    } else {\r\n      debug('work :: no packets in queue')\r\n      const done = completeParse\r\n      completeParse = null\r\n      debug('work :: done flag is %s', !!(done))\r\n      if (done) done()\r\n    }\r\n  }\r\n\r\n  writable._write = function (buf, enc, done) {\r\n    completeParse = done\r\n    debug('writable stream :: parsing buffer')\r\n    parser.parse(buf)\r\n    work()\r\n  }\r\n\r\n  function streamErrorHandler (error) {\r\n    debug('streamErrorHandler :: error', error.message)\r\n    // error.code will only be set on NodeJS env, browse don't allow to detect erros on sockets\r\n    // also emitting errors on browser seems to create issues \r\n    if (error.code) {\r\n      // handle error\r\n      debug('streamErrorHandler :: emitting error')\r\n      that.emit('error', error)\r\n    } else {\r\n      nop(error)\r\n    }\r\n  }\r\n\r\n  debug('_setupStream :: pipe stream to writable stream')\r\n  this.stream.pipe(writable)\r\n\r\n  // Suppress connection errors\r\n  this.stream.on('error', streamErrorHandler)\r\n\r\n  // Echo stream close\r\n  this.stream.on('close', function () {\r\n    debug('(%s)stream :: on close', that.options.clientId)\r\n    flushVolatile(that.outgoing)\r\n    debug('stream: emit close to MqttClient')\r\n    that.emit('close')\r\n  })\r\n\r\n  // Send a connect packet\r\n  debug('_setupStream: sending packet `connect`')\r\n  const connectPacket = Object.create(this.options)\r\n  connectPacket.cmd = 'connect'\r\n  if (this.topicAliasRecv) {\r\n    if (!connectPacket.properties) {\r\n      connectPacket.properties = {}\r\n    }\r\n    if (this.topicAliasRecv) {\r\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max\r\n    }\r\n  }\r\n  // avoid message queue\r\n  sendPacket(this, connectPacket)\r\n\r\n  // Echo connection errors\r\n  parser.on('error', this.emit.bind(this, 'error'))\r\n\r\n  // auth\r\n  if (this.options.properties) {\r\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\r\n      that.end(() =>\r\n        this.emit('error', new Error('Packet has no Authentication Method')\r\n        ))\r\n      return this\r\n    }\r\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\r\n      const authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket)\r\n      sendPacket(this, authPacket)\r\n    }\r\n  }\r\n\r\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\r\n  this.stream.setMaxListeners(1000)\r\n\r\n  clearTimeout(this.connackTimer)\r\n  this.connackTimer = setTimeout(function () {\r\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\r\n    that._cleanUp(true)\r\n  }, this.options.connectTimeout)\r\n}\r\n\r\nMqttClient.prototype._handlePacket = function (packet, done) {\r\n  const options = this.options\r\n\r\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\r\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\r\n    this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } })\r\n    return this\r\n  }\r\n  debug('_handlePacket :: emitting packetreceive')\r\n  this.emit('packetreceive', packet)\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      this._handlePublish(packet, done)\r\n      break\r\n    case 'puback':\r\n    case 'pubrec':\r\n    case 'pubcomp':\r\n    case 'suback':\r\n    case 'unsuback':\r\n      this._handleAck(packet)\r\n      done()\r\n      break\r\n    case 'pubrel':\r\n      this._handlePubrel(packet, done)\r\n      break\r\n    case 'connack':\r\n      this._handleConnack(packet)\r\n      done()\r\n      break\r\n    case 'auth':\r\n      this._handleAuth(packet)\r\n      done()\r\n      break\r\n    case 'pingresp':\r\n      this._handlePingresp(packet)\r\n      done()\r\n      break\r\n    case 'disconnect':\r\n      this._handleDisconnect(packet)\r\n      done()\r\n      break\r\n    default:\r\n      // do nothing\r\n      // maybe we should do an error handling\r\n      // or just log it\r\n      break\r\n  }\r\n}\r\n\r\nMqttClient.prototype._checkDisconnecting = function (callback) {\r\n  if (this.disconnecting) {\r\n    if (callback && callback !== nop) {\r\n      callback(new Error('client disconnecting'))\r\n    } else {\r\n      this.emit('error', new Error('client disconnecting'))\r\n    }\r\n  }\r\n  return this.disconnecting\r\n}\r\n\r\n/**\r\n * publish - publish <message> to <topic>\r\n *\r\n * @param {String} topic - topic to publish to\r\n * @param {String, Buffer} message - message to publish\r\n * @param {Object} [opts] - publish options, includes:\r\n *    {Number} qos - qos level to publish on\r\n *    {Boolean} retain - whether or not to retain the message\r\n *    {Boolean} dup - whether or not mark a message as duplicate\r\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\r\n * @param {Function} [callback] - function(err){}\r\n *    called when publish succeeds or fails\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.publish('topic', 'message');\r\n * @example\r\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\r\n * @example client.publish('topic', 'message', console.log);\r\n */\r\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\r\n  debug('publish :: message `%s` to topic `%s`', message, topic)\r\n  const options = this.options\r\n\r\n  // .publish(topic, payload, cb);\r\n  if (typeof opts === 'function') {\r\n    callback = opts\r\n    opts = null\r\n  }\r\n\r\n  // default opts\r\n  const defaultOpts = { qos: 0, retain: false, dup: false }\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  const that = this\r\n  const publishProc = function () {\r\n    let messageId = 0\r\n    if (opts.qos === 1 || opts.qos === 2) {\r\n      messageId = that._nextId()\r\n      if (messageId === null) {\r\n        debug('No messageId left')\r\n        return false\r\n      }\r\n    }\r\n    const packet = {\r\n      cmd: 'publish',\r\n      topic: topic,\r\n      payload: message,\r\n      qos: opts.qos,\r\n      retain: opts.retain,\r\n      messageId: messageId,\r\n      dup: opts.dup\r\n    }\r\n\r\n    if (options.protocolVersion === 5) {\r\n      packet.properties = opts.properties\r\n    }\r\n\r\n    debug('publish :: qos', opts.qos)\r\n    switch (opts.qos) {\r\n      case 1:\r\n      case 2:\r\n        // Add to callbacks\r\n        that.outgoing[packet.messageId] = {\r\n          volatile: false,\r\n          cb: callback || nop\r\n        }\r\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\r\n        that._sendPacket(packet, undefined, opts.cbStorePut)\r\n        break\r\n      default:\r\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\r\n        that._sendPacket(packet, callback, opts.cbStorePut)\r\n        break\r\n    }\r\n    return true\r\n  }\r\n\r\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\r\n    this._storeProcessingQueue.push(\r\n      {\r\n        invoke: publishProc,\r\n        cbStorePut: opts.cbStorePut,\r\n        callback: callback\r\n      }\r\n    )\r\n  }\r\n  return this\r\n}\r\n\r\n/**\r\n * subscribe - subscribe to <topic>\r\n *\r\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Number} qos - subscribe qos level\r\n * @param {Function} [callback] - function(err, granted){} where:\r\n *    {Error} err - subscription error (none at the moment!)\r\n *    {Array} granted - array of {topic: 't', qos: 0}\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.subscribe('topic');\r\n * @example client.subscribe('topic', {qos: 1});\r\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\r\n * @example client.subscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.subscribe = function () {\r\n  const that = this\r\n  const args = new Array(arguments.length)\r\n  for (let i = 0; i < arguments.length; i++) {\r\n    args[i] = arguments[i]\r\n  }\r\n  const subs = []\r\n  let obj = args.shift()\r\n  const resubscribe = obj.resubscribe\r\n  let callback = args.pop() || nop\r\n  let opts = args.pop()\r\n  const version = this.options.protocolVersion\r\n\r\n  delete obj.resubscribe\r\n\r\n  if (typeof obj === 'string') {\r\n    obj = [obj]\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    opts = callback\r\n    callback = nop\r\n  }\r\n\r\n  const invalidTopic = validations.validateTopics(obj)\r\n  if (invalidTopic !== null) {\r\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\r\n    return this\r\n  }\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    debug('subscribe: discconecting true')\r\n    return this\r\n  }\r\n\r\n  const defaultOpts = {\r\n    qos: 0\r\n  }\r\n  if (version === 5) {\r\n    defaultOpts.nl = false\r\n    defaultOpts.rap = false\r\n    defaultOpts.rh = 0\r\n  }\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (Array.isArray(obj)) {\r\n    obj.forEach(function (topic) {\r\n      debug('subscribe: array topic %s', topic)\r\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) ||\r\n        that._resubscribeTopics[topic].qos < opts.qos ||\r\n          resubscribe) {\r\n        const currentOpts = {\r\n          topic: topic,\r\n          qos: opts.qos\r\n        }\r\n        if (version === 5) {\r\n          currentOpts.nl = opts.nl\r\n          currentOpts.rap = opts.rap\r\n          currentOpts.rh = opts.rh\r\n          currentOpts.properties = opts.properties\r\n        }\r\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\r\n        subs.push(currentOpts)\r\n      }\r\n    })\r\n  } else {\r\n    Object\r\n      .keys(obj)\r\n      .forEach(function (k) {\r\n        debug('subscribe: object topic %s', k)\r\n        if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) ||\r\n          that._resubscribeTopics[k].qos < obj[k].qos ||\r\n            resubscribe) {\r\n          const currentOpts = {\r\n            topic: k,\r\n            qos: obj[k].qos\r\n          }\r\n          if (version === 5) {\r\n            currentOpts.nl = obj[k].nl\r\n            currentOpts.rap = obj[k].rap\r\n            currentOpts.rh = obj[k].rh\r\n            currentOpts.properties = opts.properties\r\n          }\r\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\r\n          subs.push(currentOpts)\r\n        }\r\n      })\r\n  }\r\n\r\n  if (!subs.length) {\r\n    callback(null, [])\r\n    return this\r\n  }\r\n\r\n  const subscribeProc = function () {\r\n    const messageId = that._nextId()\r\n    if (messageId === null) {\r\n      debug('No messageId left')\r\n      return false\r\n    }\r\n\r\n    const packet = {\r\n      cmd: 'subscribe',\r\n      subscriptions: subs,\r\n      qos: 1,\r\n      retain: false,\r\n      dup: false,\r\n      messageId: messageId\r\n    }\r\n\r\n    if (opts.properties) {\r\n      packet.properties = opts.properties\r\n    }\r\n\r\n    // subscriptions to resubscribe to in case of disconnect\r\n    if (that.options.resubscribe) {\r\n      debug('subscribe :: resubscribe true')\r\n      const topics = []\r\n      subs.forEach(function (sub) {\r\n        if (that.options.reconnectPeriod > 0) {\r\n          const topic = { qos: sub.qos }\r\n          if (version === 5) {\r\n            topic.nl = sub.nl || false\r\n            topic.rap = sub.rap || false\r\n            topic.rh = sub.rh || 0\r\n            topic.properties = sub.properties\r\n          }\r\n          that._resubscribeTopics[sub.topic] = topic\r\n          topics.push(sub.topic)\r\n        }\r\n      })\r\n      that.messageIdToTopic[packet.messageId] = topics\r\n    }\r\n\r\n    that.outgoing[packet.messageId] = {\r\n      volatile: true,\r\n      cb: function (err, packet) {\r\n        if (!err) {\r\n          const granted = packet.granted\r\n          for (let i = 0; i < granted.length; i += 1) {\r\n            subs[i].qos = granted[i]\r\n          }\r\n        }\r\n\r\n        callback(err, subs)\r\n      }\r\n    }\r\n    debug('subscribe :: call _sendPacket')\r\n    that._sendPacket(packet)\r\n    return true\r\n  }\r\n\r\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\r\n    this._storeProcessingQueue.push(\r\n      {\r\n        invoke: subscribeProc,\r\n        callback: callback\r\n      }\r\n    )\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * unsubscribe - unsubscribe from topic(s)\r\n *\r\n * @param {String, Array} topic - topics to unsubscribe from\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Object} properties - properties of unsubscribe packet\r\n * @param {Function} [callback] - callback fired on unsuback\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.unsubscribe('topic');\r\n * @example client.unsubscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.unsubscribe = function () {\r\n  const that = this\r\n  const args = new Array(arguments.length)\r\n  for (let i = 0; i < arguments.length; i++) {\r\n    args[i] = arguments[i]\r\n  }\r\n  let topic = args.shift()\r\n  let callback = args.pop() || nop\r\n  let opts = args.pop()\r\n  if (typeof topic === 'string') {\r\n    topic = [topic]\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    opts = callback\r\n    callback = nop\r\n  }\r\n\r\n  const invalidTopic = validations.validateTopics(topic)\r\n  if (invalidTopic !== null) {\r\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\r\n    return this\r\n  }\r\n\r\n  if (that._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  const unsubscribeProc = function () {\r\n    const messageId = that._nextId()\r\n    if (messageId === null) {\r\n      debug('No messageId left')\r\n      return false\r\n    }\r\n    const packet = {\r\n      cmd: 'unsubscribe',\r\n      qos: 1,\r\n      messageId: messageId\r\n    }\r\n\r\n    if (typeof topic === 'string') {\r\n      packet.unsubscriptions = [topic]\r\n    } else if (Array.isArray(topic)) {\r\n      packet.unsubscriptions = topic\r\n    }\r\n\r\n    if (that.options.resubscribe) {\r\n      packet.unsubscriptions.forEach(function (topic) {\r\n        delete that._resubscribeTopics[topic]\r\n      })\r\n    }\r\n\r\n    if (typeof opts === 'object' && opts.properties) {\r\n      packet.properties = opts.properties\r\n    }\r\n\r\n    that.outgoing[packet.messageId] = {\r\n      volatile: true,\r\n      cb: callback\r\n    }\r\n\r\n    debug('unsubscribe: call _sendPacket')\r\n    that._sendPacket(packet)\r\n\r\n    return true\r\n  }\r\n\r\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\r\n    this._storeProcessingQueue.push(\r\n      {\r\n        invoke: unsubscribeProc,\r\n        callback: callback\r\n      }\r\n    )\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * end - close connection\r\n *\r\n * @returns {MqttClient} this - for chaining\r\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n * @param {Object} opts - added to the disconnect packet\r\n * @param {Function} cb - called when the client has been closed\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.end = function (force, opts, cb) {\r\n  const that = this\r\n\r\n  debug('end :: (%s)', this.options.clientId)\r\n\r\n  if (force == null || typeof force !== 'boolean') {\r\n    cb = opts || nop\r\n    opts = force\r\n    force = false\r\n    if (typeof opts !== 'object') {\r\n      cb = opts\r\n      opts = null\r\n      if (typeof cb !== 'function') {\r\n        cb = nop\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof opts !== 'object') {\r\n    cb = opts\r\n    opts = null\r\n  }\r\n\r\n  debug('end :: cb? %s', !!cb)\r\n  cb = cb || nop\r\n\r\n  function closeStores () {\r\n    debug('end :: closeStores: closing incoming and outgoing stores')\r\n    that.disconnected = true\r\n    that.incomingStore.close(function (e1) {\r\n      that.outgoingStore.close(function (e2) {\r\n        debug('end :: closeStores: emitting end')\r\n        that.emit('end')\r\n        if (cb) {\r\n          const err = e1 || e2\r\n          debug('end :: closeStores: invoking callback with args')\r\n          cb(err)\r\n        }\r\n      })\r\n    })\r\n    if (that._deferredReconnect) {\r\n      that._deferredReconnect()\r\n    }\r\n  }\r\n\r\n  function finish () {\r\n    // defer closesStores of an I/O cycle,\r\n    // just to make sure things are\r\n    // ok for websockets\r\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\r\n    that._cleanUp(force, () => {\r\n      debug('end :: finish :: calling process.nextTick on closeStores')\r\n      // const boundProcess = nextTick.bind(null, closeStores)\r\n      nextTick(closeStores.bind(that))\r\n    }, opts)\r\n  }\r\n\r\n  if (this.disconnecting) {\r\n    cb()\r\n    return this\r\n  }\r\n\r\n  this._clearReconnect()\r\n\r\n  this.disconnecting = true\r\n\r\n  if (!force && Object.keys(this.outgoing).length > 0) {\r\n    // wait 10ms, just to be sure we received all of it\r\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\r\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\r\n  } else {\r\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\r\n    finish()\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * removeOutgoingMessage - remove a message in outgoing store\r\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n *\r\n * @param {Number} messageId - messageId to remove message\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.removeOutgoingMessage(client.getLastAllocated());\r\n */\r\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\r\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\r\n  delete this.outgoing[messageId]\r\n  this.outgoingStore.del({ messageId: messageId }, function () {\r\n    cb(new Error('Message removed'))\r\n  })\r\n  return this\r\n}\r\n\r\n/**\r\n * reconnect - connect again using the same options as connect()\r\n *\r\n * @param {Object} [opts] - optional reconnect options, includes:\r\n *    {Store} incomingStore - a store for the incoming packets\r\n *    {Store} outgoingStore - a store for the outgoing packets\r\n *    if opts is not given, current stores are used\r\n * @returns {MqttClient} this - for chaining\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.reconnect = function (opts) {\r\n  debug('client reconnect')\r\n  const that = this\r\n  const f = function () {\r\n    if (opts) {\r\n      that.options.incomingStore = opts.incomingStore\r\n      that.options.outgoingStore = opts.outgoingStore\r\n    } else {\r\n      that.options.incomingStore = null\r\n      that.options.outgoingStore = null\r\n    }\r\n    that.incomingStore = that.options.incomingStore || new Store()\r\n    that.outgoingStore = that.options.outgoingStore || new Store()\r\n    that.disconnecting = false\r\n    that.disconnected = false\r\n    that._deferredReconnect = null\r\n    that._reconnect()\r\n  }\r\n\r\n  if (this.disconnecting && !this.disconnected) {\r\n    this._deferredReconnect = f\r\n  } else {\r\n    f()\r\n  }\r\n  return this\r\n}\r\n\r\n/**\r\n * _reconnect - implement reconnection\r\n * @api privateish\r\n */\r\nMqttClient.prototype._reconnect = function () {\r\n  debug('_reconnect: emitting reconnect to client')\r\n  this.emit('reconnect')\r\n  if (this.connected) {\r\n    this.end(() => { this._setupStream() })\r\n    debug('client already connected. disconnecting first.')\r\n  } else {\r\n    debug('_reconnect: calling _setupStream')\r\n    this._setupStream()\r\n  }\r\n}\r\n\r\n/**\r\n * _setupReconnect - setup reconnect timer\r\n */\r\nMqttClient.prototype._setupReconnect = function () {\r\n  const that = this\r\n\r\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\r\n    if (!this.reconnecting) {\r\n      debug('_setupReconnect :: emit `offline` state')\r\n      this.emit('offline')\r\n      debug('_setupReconnect :: set `reconnecting` to `true`')\r\n      this.reconnecting = true\r\n    }\r\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\r\n    that.reconnectTimer = setInterval(function () {\r\n      debug('reconnectTimer :: reconnect triggered!')\r\n      that._reconnect()\r\n    }, that.options.reconnectPeriod)\r\n  } else {\r\n    debug('_setupReconnect :: doing nothing...')\r\n  }\r\n}\r\n\r\n/**\r\n * _clearReconnect - clear the reconnect timer\r\n */\r\nMqttClient.prototype._clearReconnect = function () {\r\n  debug('_clearReconnect : clearing reconnect timer')\r\n  if (this.reconnectTimer) {\r\n    clearInterval(this.reconnectTimer)\r\n    this.reconnectTimer = null\r\n  }\r\n}\r\n\r\n/**\r\n * _cleanUp - clean up on connection end\r\n * @api private\r\n */\r\nMqttClient.prototype._cleanUp = function (forced, done) {\r\n  const opts = arguments[2]\r\n  if (done) {\r\n    debug('_cleanUp :: done callback provided for on stream close')\r\n    this.stream.on('close', done)\r\n  }\r\n\r\n  debug('_cleanUp :: forced? %s', forced)\r\n  if (forced) {\r\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\r\n      flush(this.outgoing)\r\n    }\r\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\r\n    this.stream.destroy()\r\n  } else {\r\n    const packet = xtend({ cmd: 'disconnect' }, opts)\r\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\r\n    this._sendPacket(\r\n      packet,\r\n      setImmediate.bind(\r\n        null,\r\n        this.stream.end.bind(this.stream)\r\n      )\r\n    )\r\n  }\r\n\r\n  if (!this.disconnecting) {\r\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\r\n    this._clearReconnect()\r\n    this._setupReconnect()\r\n  }\r\n\r\n  if (this.pingTimer !== null) {\r\n    debug('_cleanUp :: clearing pingTimer')\r\n    this.pingTimer.clear()\r\n    this.pingTimer = null\r\n  }\r\n\r\n  if (done && !this.connected) {\r\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\r\n    this.stream.removeListener('close', done)\r\n    done()\r\n  }\r\n}\r\n\r\n/**\r\n * _sendPacket - send or queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\r\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\r\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\r\n  cbStorePut = cbStorePut || nop\r\n  cb = cb || nop\r\n\r\n  const err = applyTopicAlias(this, packet)\r\n  if (err) {\r\n    cb(err)\r\n    return\r\n  }\r\n\r\n  if (!this.connected) {\r\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\r\n    if (packet.cmd === 'auth') {\r\n      this._shiftPingInterval()\r\n      sendPacket(this, packet, cb)\r\n      return\r\n    }\r\n\r\n    debug('_sendPacket :: client not connected. Storing packet offline.')\r\n    this._storePacket(packet, cb, cbStorePut)\r\n    return\r\n  }\r\n\r\n  // When sending a packet, reschedule the ping timer\r\n  this._shiftPingInterval()\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      break\r\n    case 'pubrel':\r\n      storeAndSend(this, packet, cb, cbStorePut)\r\n      return\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      return\r\n  }\r\n\r\n  switch (packet.qos) {\r\n    case 2:\r\n    case 1:\r\n      storeAndSend(this, packet, cb, cbStorePut)\r\n      break\r\n    /**\r\n     * no need of case here since it will be caught by default\r\n     * and jshint comply that before default it must be a break\r\n     * anyway it will result in -1 evaluation\r\n     */\r\n    case 0:\r\n      /* falls through */\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      break\r\n  }\r\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\r\n}\r\n\r\n/**\r\n * _storePacket - queue a packet\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @param {Function} cbStorePut - called when message is put into outgoingStore\r\n * @api private\r\n */\r\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\r\n  debug('_storePacket :: packet: %o', packet)\r\n  debug('_storePacket :: cb? %s', !!cb)\r\n  cbStorePut = cbStorePut || nop\r\n\r\n  let storePacket = packet\r\n  if (storePacket.cmd === 'publish') {\r\n    // The original packet is for sending.\r\n    // The cloned storePacket is for storing to resend on reconnect.\r\n    // Topic Alias must not be used after disconnected.\r\n    storePacket = clone(packet)\r\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket)\r\n    if (err) {\r\n      return cb && cb(err)\r\n    }\r\n  }\r\n  // check that the packet is not a qos of 0, or that the command is not a publish\r\n  if (((storePacket.qos || 0) === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {\r\n    this.queue.push({ packet: storePacket, cb: cb })\r\n  } else if (storePacket.qos > 0) {\r\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null\r\n    this.outgoingStore.put(storePacket, function (err) {\r\n      if (err) {\r\n        return cb && cb(err)\r\n      }\r\n      cbStorePut()\r\n    })\r\n  } else if (cb) {\r\n    cb(new Error('No connection to broker'))\r\n  }\r\n}\r\n\r\n/**\r\n * _setupPingTimer - setup the ping timer\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupPingTimer = function () {\r\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\r\n  const that = this\r\n\r\n  if (!this.pingTimer && this.options.keepalive) {\r\n    this.pingResp = true\r\n    this.pingTimer = reInterval(function () {\r\n      that._checkPing()\r\n    }, this.options.keepalive * 1000)\r\n  }\r\n}\r\n\r\n/**\r\n * _shiftPingInterval - reschedule the ping interval\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._shiftPingInterval = function () {\r\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\r\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\r\n  }\r\n}\r\n/**\r\n * _checkPing - check if a pingresp has come back, and ping the server again\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._checkPing = function () {\r\n  debug('_checkPing :: checking ping...')\r\n  if (this.pingResp) {\r\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\r\n    this.pingResp = false\r\n    this._sendPacket({ cmd: 'pingreq' })\r\n  } else {\r\n    // do a forced cleanup since socket will be in bad shape\r\n    debug('_checkPing :: calling _cleanUp with force true')\r\n    this._cleanUp(true)\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePingresp - handle a pingresp\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePingresp = function () {\r\n  this.pingResp = true\r\n}\r\n\r\n/**\r\n * _handleConnack\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handleConnack = function (packet) {\r\n  debug('_handleConnack')\r\n  const options = this.options\r\n  const version = options.protocolVersion\r\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\r\n\r\n  clearTimeout(this.connackTimer)\r\n  delete this.topicAliasSend\r\n\r\n  if (packet.properties) {\r\n    if (packet.properties.topicAliasMaximum) {\r\n      if (packet.properties.topicAliasMaximum > 0xffff) {\r\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'))\r\n        return\r\n      }\r\n      if (packet.properties.topicAliasMaximum > 0) {\r\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum)\r\n      }\r\n    }\r\n    if (packet.properties.serverKeepAlive && options.keepalive) {\r\n      options.keepalive = packet.properties.serverKeepAlive\r\n      this._shiftPingInterval()\r\n    }\r\n    if (packet.properties.maximumPacketSize) {\r\n      if (!options.properties) { options.properties = {} }\r\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\r\n    }\r\n  }\r\n\r\n  if (rc === 0) {\r\n    this.reconnecting = false\r\n    this._onConnect(packet)\r\n  } else if (rc > 0) {\r\n    const err = new Error('Connection refused: ' + errors[rc])\r\n    err.code = rc\r\n    this.emit('error', err)\r\n  }\r\n}\r\n\r\nMqttClient.prototype._handleAuth = function (packet) {\r\n  const options = this.options\r\n  const version = options.protocolVersion\r\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\r\n\r\n  if (version !== 5) {\r\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version)\r\n    err.code = rc\r\n    this.emit('error', err)\r\n    return\r\n  }\r\n\r\n  const that = this\r\n  this.handleAuth(packet, function (err, packet) {\r\n    if (err) {\r\n      that.emit('error', err)\r\n      return\r\n    }\r\n\r\n    if (rc === 24) {\r\n      that.reconnecting = false\r\n      that._sendPacket(packet)\r\n    } else {\r\n      const error = new Error('Connection refused: ' + errors[rc])\r\n      err.code = rc\r\n      that.emit('error', error)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * @param packet the packet received by the broker\r\n * @return the auth packet to be returned to the broker\r\n * @api public\r\n */\r\nMqttClient.prototype.handleAuth = function (packet, callback) {\r\n  callback()\r\n}\r\n\r\n/**\r\n * _handlePublish\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n/*\r\nthose late 2 case should be rewrite to comply with coding style:\r\n\r\ncase 1:\r\ncase 0:\r\n  // do not wait sending a puback\r\n  // no callback passed\r\n  if (1 === qos) {\r\n    this._sendPacket({\r\n      cmd: 'puback',\r\n      messageId: messageId\r\n    });\r\n  }\r\n  // emit the message event for both qos 1 and 0\r\n  this.emit('message', topic, message, packet);\r\n  this.handleMessage(packet, done);\r\n  break;\r\ndefault:\r\n  // do nothing but every switch mus have a default\r\n  // log or throw an error about unknown qos\r\n  break;\r\n\r\nfor now i just suppressed the warnings\r\n*/\r\nMqttClient.prototype._handlePublish = function (packet, done) {\r\n  debug('_handlePublish: packet %o', packet)\r\n  done = typeof done !== 'undefined' ? done : nop\r\n  let topic = packet.topic.toString()\r\n  const message = packet.payload\r\n  const qos = packet.qos\r\n  const messageId = packet.messageId\r\n  const that = this\r\n  const options = this.options\r\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\r\n  if (this.options.protocolVersion === 5) {\r\n    let alias\r\n    if (packet.properties) {\r\n      alias = packet.properties.topicAlias\r\n    }\r\n    if (typeof alias !== 'undefined') {\r\n      if (topic.length === 0) {\r\n        if (alias > 0 && alias <= 0xffff) {\r\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias)\r\n          if (gotTopic) {\r\n            topic = gotTopic\r\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias)\r\n          } else {\r\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias)\r\n            this.emit('error', new Error('Received unregistered Topic Alias'))\r\n            return\r\n          }\r\n        } else {\r\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\r\n          this.emit('error', new Error('Received Topic Alias is out of range'))\r\n          return\r\n        }\r\n      } else {\r\n        if (this.topicAliasRecv.put(topic, alias)) {\r\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias)\r\n        } else {\r\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\r\n          this.emit('error', new Error('Received Topic Alias is out of range'))\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n  debug('_handlePublish: qos %d', qos)\r\n  switch (qos) {\r\n    case 2: {\r\n      options.customHandleAcks(topic, message, packet, function (error, code) {\r\n        if (!(error instanceof Error)) {\r\n          code = error\r\n          error = null\r\n        }\r\n        if (error) { return that.emit('error', error) }\r\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\r\n        if (code) {\r\n          that._sendPacket({ cmd: 'pubrec', messageId: messageId, reasonCode: code }, done)\r\n        } else {\r\n          that.incomingStore.put(packet, function () {\r\n            that._sendPacket({ cmd: 'pubrec', messageId: messageId }, done)\r\n          })\r\n        }\r\n      })\r\n      break\r\n    }\r\n    case 1: {\r\n      // emit the message event\r\n      options.customHandleAcks(topic, message, packet, function (error, code) {\r\n        if (!(error instanceof Error)) {\r\n          code = error\r\n          error = null\r\n        }\r\n        if (error) { return that.emit('error', error) }\r\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\r\n        if (!code) { that.emit('message', topic, message, packet) }\r\n        that.handleMessage(packet, function (err) {\r\n          if (err) {\r\n            return done && done(err)\r\n          }\r\n          that._sendPacket({ cmd: 'puback', messageId: messageId, reasonCode: code }, done)\r\n        })\r\n      })\r\n      break\r\n    }\r\n    case 0:\r\n      // emit the message event\r\n      this.emit('message', topic, message, packet)\r\n      this.handleMessage(packet, done)\r\n      break\r\n    default:\r\n      // do nothing\r\n      debug('_handlePublish: unknown QoS. Doing nothing.')\r\n      // log or throw an error about unknown qos\r\n      break\r\n  }\r\n}\r\n\r\n/**\r\n * Handle messages with backpressure support, one at a time.\r\n * Override at will.\r\n *\r\n * @param Packet packet the packet\r\n * @param Function callback call when finished\r\n * @api public\r\n */\r\nMqttClient.prototype.handleMessage = function (packet, callback) {\r\n  callback()\r\n}\r\n\r\n/**\r\n * _handleAck\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n\r\nMqttClient.prototype._handleAck = function (packet) {\r\n  /* eslint no-fallthrough: \"off\" */\r\n  const messageId = packet.messageId\r\n  const type = packet.cmd\r\n  let response = null\r\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\r\n  const that = this\r\n  let err\r\n\r\n  // Checking `!cb` happens to work, but it's not technically \"correct\".\r\n  //\r\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\r\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\r\n  //\r\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\r\n  // there's no reason to change it and risk (another) regression.\r\n  //\r\n  // The only reason this code works is becaues code in MqttClient.publish,\r\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\r\n  // have a callback even if the user doesn't pass one in.)\r\n  if (!cb) {\r\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\r\n    // Server sent an ack in error, ignore it.\r\n    return\r\n  }\r\n\r\n  // Process\r\n  debug('_handleAck :: packet type', type)\r\n  switch (type) {\r\n    case 'pubcomp':\r\n      // same thing as puback for QoS 2\r\n    case 'puback': {\r\n      const pubackRC = packet.reasonCode\r\n      // Callback - we're done\r\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\r\n        err = new Error('Publish error: ' + errors[pubackRC])\r\n        err.code = pubackRC\r\n        cb(err, packet)\r\n      }\r\n      delete this.outgoing[messageId]\r\n      this.outgoingStore.del(packet, cb)\r\n      this.messageIdProvider.deallocate(messageId)\r\n      this._invokeStoreProcessingQueue()\r\n      break\r\n    }\r\n    case 'pubrec': {\r\n      response = {\r\n        cmd: 'pubrel',\r\n        qos: 2,\r\n        messageId: messageId\r\n      }\r\n      const pubrecRC = packet.reasonCode\r\n\r\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\r\n        err = new Error('Publish error: ' + errors[pubrecRC])\r\n        err.code = pubrecRC\r\n        cb(err, packet)\r\n      } else {\r\n        this._sendPacket(response)\r\n      }\r\n      break\r\n    }\r\n    case 'suback': {\r\n      delete this.outgoing[messageId]\r\n      this.messageIdProvider.deallocate(messageId)\r\n      for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\r\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\r\n          // suback with Failure status\r\n          const topics = this.messageIdToTopic[messageId]\r\n          if (topics) {\r\n            topics.forEach(function (topic) {\r\n              delete that._resubscribeTopics[topic]\r\n            })\r\n          }\r\n        }\r\n      }\r\n      this._invokeStoreProcessingQueue()\r\n      cb(null, packet)\r\n      break\r\n    }\r\n    case 'unsuback': {\r\n      delete this.outgoing[messageId]\r\n      this.messageIdProvider.deallocate(messageId)\r\n      this._invokeStoreProcessingQueue()\r\n      cb(null)\r\n      break\r\n    }\r\n    default:\r\n      that.emit('error', new Error('unrecognized packet type'))\r\n  }\r\n\r\n  if (this.disconnecting &&\r\n      Object.keys(this.outgoing).length === 0) {\r\n    this.emit('outgoingEmpty')\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePubrel\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePubrel = function (packet, callback) {\r\n  debug('handling pubrel packet')\r\n  callback = typeof callback !== 'undefined' ? callback : nop\r\n  const messageId = packet.messageId\r\n  const that = this\r\n\r\n  const comp = { cmd: 'pubcomp', messageId: messageId }\r\n\r\n  that.incomingStore.get(packet, function (err, pub) {\r\n    if (!err) {\r\n      that.emit('message', pub.topic, pub.payload, pub)\r\n      that.handleMessage(pub, function (err) {\r\n        if (err) {\r\n          return callback(err)\r\n        }\r\n        that.incomingStore.del(pub, nop)\r\n        that._sendPacket(comp, callback)\r\n      })\r\n    } else {\r\n      that._sendPacket(comp, callback)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * _handleDisconnect\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handleDisconnect = function (packet) {\r\n  this.emit('disconnect', packet)\r\n}\r\n\r\n/**\r\n * _nextId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype._nextId = function () {\r\n  return this.messageIdProvider.allocate()\r\n}\r\n\r\n/**\r\n * getLastMessageId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype.getLastMessageId = function () {\r\n  return this.messageIdProvider.getLastAllocated()\r\n}\r\n\r\n/**\r\n * _resubscribe\r\n * @api private\r\n */\r\nMqttClient.prototype._resubscribe = function () {\r\n  debug('_resubscribe')\r\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\r\n  if (!this._firstConnection &&\r\n      (this.options.clean || (this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent)) &&\r\n      _resubscribeTopicsKeys.length > 0) {\r\n    if (this.options.resubscribe) {\r\n      if (this.options.protocolVersion === 5) {\r\n        debug('_resubscribe: protocolVersion 5')\r\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\r\n          const resubscribeTopic = {}\r\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\r\n          resubscribeTopic.resubscribe = true\r\n          this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties })\r\n        }\r\n      } else {\r\n        this._resubscribeTopics.resubscribe = true\r\n        this.subscribe(this._resubscribeTopics)\r\n      }\r\n    } else {\r\n      this._resubscribeTopics = {}\r\n    }\r\n  }\r\n\r\n  this._firstConnection = false\r\n}\r\n\r\n/**\r\n * _onConnect\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._onConnect = function (packet) {\r\n  if (this.disconnected) {\r\n    this.emit('connect', packet)\r\n    return\r\n  }\r\n\r\n  const that = this\r\n\r\n  this.connackPacket = packet\r\n  this.messageIdProvider.clear()\r\n  this._setupPingTimer()\r\n\r\n  this.connected = true\r\n\r\n  function startStreamProcess () {\r\n    let outStore = that.outgoingStore.createStream()\r\n\r\n    function clearStoreProcessing () {\r\n      that._storeProcessing = false\r\n      that._packetIdsDuringStoreProcessing = {}\r\n    }\r\n\r\n    that.once('close', remove)\r\n    outStore.on('error', function (err) {\r\n      clearStoreProcessing()\r\n      that._flushStoreProcessingQueue()\r\n      that.removeListener('close', remove)\r\n      that.emit('error', err)\r\n    })\r\n\r\n    function remove () {\r\n      outStore.destroy()\r\n      outStore = null\r\n      that._flushStoreProcessingQueue()\r\n      clearStoreProcessing()\r\n    }\r\n\r\n    function storeDeliver () {\r\n      // edge case, we wrapped this twice\r\n      if (!outStore) {\r\n        return\r\n      }\r\n      that._storeProcessing = true\r\n\r\n      const packet = outStore.read(1)\r\n\r\n      let cb\r\n\r\n      if (!packet) {\r\n        // read when data is available in the future\r\n        outStore.once('readable', storeDeliver)\r\n        return\r\n      }\r\n\r\n      // Skip already processed store packets\r\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\r\n        storeDeliver()\r\n        return\r\n      }\r\n\r\n      // Avoid unnecessary stream read operations when disconnected\r\n      if (!that.disconnecting && !that.reconnectTimer) {\r\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\r\n        that.outgoing[packet.messageId] = {\r\n          volatile: false,\r\n          cb: function (err, status) {\r\n            // Ensure that the original callback passed in to publish gets invoked\r\n            if (cb) {\r\n              cb(err, status)\r\n            }\r\n\r\n            storeDeliver()\r\n          }\r\n        }\r\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\r\n        if (that.messageIdProvider.register(packet.messageId)) {\r\n          that._sendPacket(packet)\r\n        } else {\r\n          debug('messageId: %d has already used.', packet.messageId)\r\n        }\r\n      } else if (outStore.destroy) {\r\n        outStore.destroy()\r\n      }\r\n    }\r\n\r\n    outStore.on('end', function () {\r\n      let allProcessed = true\r\n      for (const id in that._packetIdsDuringStoreProcessing) {\r\n        if (!that._packetIdsDuringStoreProcessing[id]) {\r\n          allProcessed = false\r\n          break\r\n        }\r\n      }\r\n      if (allProcessed) {\r\n        clearStoreProcessing()\r\n        that.removeListener('close', remove)\r\n        that._invokeAllStoreProcessingQueue()\r\n        that.emit('connect', packet)\r\n      } else {\r\n        startStreamProcess()\r\n      }\r\n    })\r\n    storeDeliver()\r\n  }\r\n  // start flowing\r\n  startStreamProcess()\r\n}\r\n\r\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\r\n  if (this._storeProcessingQueue.length > 0) {\r\n    const f = this._storeProcessingQueue[0]\r\n    if (f && f.invoke()) {\r\n      this._storeProcessingQueue.shift()\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\r\n  while (this._invokeStoreProcessingQueue()) { /* empty */ }\r\n}\r\n\r\nMqttClient.prototype._flushStoreProcessingQueue = function () {\r\n  for (const f of this._storeProcessingQueue) {\r\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))\r\n    if (f.callback) f.callback(new Error('Connection closed'))\r\n  }\r\n  this._storeProcessingQueue.splice(0)\r\n}\r\n\r\nmodule.exports = MqttClient\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}