{"ast":null,"code":"var __extends = this && this.t || function () {\n  var extendStatics = function (e, r) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, r) {\n      e.__proto__ = r;\n    } || function (e, r) {\n      for (var i in r) if (Object.prototype.hasOwnProperty.call(r, i)) e[i] = r[i];\n    };\n    return extendStatics(e, r);\n  };\n  return function (e, r) {\n    if (typeof r !== \"function\" && r !== null) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n    extendStatics(e, r);\n    function __() {\n      this.constructor = e;\n    }\n    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());\n  };\n}();\nvar __read = this && this.q || function (e, r) {\n  var i = typeof Symbol === \"function\" && e[Symbol.iterator];\n  if (!i) return e;\n  var t = i.call(e),\n    n,\n    s = [],\n    f;\n  try {\n    while ((r === void 0 || r-- > 0) && !(n = t.next()).done) s.push(n.value);\n  } catch (e) {\n    f = {\n      error: e\n    };\n  } finally {\n    try {\n      if (n && !n.done && (i = t[\"return\"])) i.call(t);\n    } finally {\n      if (f) throw f.error;\n    }\n  }\n  return s;\n};\nvar __values = this && this.V || function (e) {\n  var r = typeof Symbol === \"function\" && Symbol.iterator,\n    i = r && e[r],\n    t = 0;\n  if (i) return i.call(e);\n  if (e && typeof e.length === \"number\") return {\n    next: function () {\n      if (e && t >= e.length) e = void 0;\n      return {\n        value: e && e[t++],\n        done: !e\n      };\n    }\n  };\n  throw new TypeError(r ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { TreeNode, TreeNodeEnableIndex } from \"./TreeNode\";\nimport { Container } from \"../../ContainerBase\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = function (e) {\n  __extends(TreeContainer, e);\n  function TreeContainer(r, i) {\n    if (r === void 0) {\n      r = function (e, r) {\n        if (e < r) return -1;\n        if (e > r) return 1;\n        return 0;\n      };\n    }\n    if (i === void 0) {\n      i = false;\n    }\n    var t = e.call(this) || this;\n    t.W = undefined;\n    t.$ = r;\n    if (i) {\n      t.re = TreeNodeEnableIndex;\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n        if (t) {\n          var n = t.rr;\n          while (n !== this.h) {\n            n.tr += 1;\n            n = n.rr;\n          }\n          var s = this.fe(t);\n          if (s) {\n            var f = s,\n              h = f.parentNode,\n              u = f.grandParent,\n              a = f.curNode;\n            h.ie();\n            u.ie();\n            a.ie();\n          }\n        }\n        return this.M;\n      };\n      t.G = function (e) {\n        var r = this.he(e);\n        while (r !== this.h) {\n          r.tr -= 1;\n          r = r.rr;\n        }\n      };\n    } else {\n      t.re = TreeNode;\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n        if (t) this.fe(t);\n        return this.M;\n      };\n      t.G = t.he;\n    }\n    t.h = new t.re();\n    return t;\n  }\n  TreeContainer.prototype.U = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        e = e.N;\n      } else if (t > 0) {\n        i = e;\n        e = e.K;\n      } else return e;\n    }\n    return i;\n  };\n  TreeContainer.prototype.X = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t <= 0) {\n        e = e.N;\n      } else {\n        i = e;\n        e = e.K;\n      }\n    }\n    return i;\n  };\n  TreeContainer.prototype.Y = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else if (t > 0) {\n        e = e.K;\n      } else return e;\n    }\n    return i;\n  };\n  TreeContainer.prototype.Z = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else {\n        e = e.K;\n      }\n    }\n    return i;\n  };\n  TreeContainer.prototype.ue = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r === this.h) return;\n      if (e.ee === 1) {\n        e.ee = 0;\n        return;\n      }\n      if (e === r.K) {\n        var i = r.N;\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n          if (r === this.W) {\n            this.W = r.ne();\n          } else r.ne();\n        } else {\n          if (i.N && i.N.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.N.ee = 0;\n            if (r === this.W) {\n              this.W = r.ne();\n            } else r.ne();\n            return;\n          } else if (i.K && i.K.ee === 1) {\n            i.ee = 1;\n            i.K.ee = 0;\n            i.te();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      } else {\n        var i = r.K;\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n          if (r === this.W) {\n            this.W = r.te();\n          } else r.te();\n        } else {\n          if (i.K && i.K.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.K.ee = 0;\n            if (r === this.W) {\n              this.W = r.te();\n            } else r.te();\n            return;\n          } else if (i.N && i.N.ee === 1) {\n            i.ee = 1;\n            i.N.ee = 0;\n            i.ne();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      }\n    }\n  };\n  TreeContainer.prototype.he = function (e) {\n    var r, i;\n    if (this.M === 1) {\n      this.clear();\n      return this.h;\n    }\n    var t = e;\n    while (t.K || t.N) {\n      if (t.N) {\n        t = t.N;\n        while (t.K) t = t.K;\n      } else {\n        t = t.K;\n      }\n      r = __read([t.u, e.u], 2), e.u = r[0], t.u = r[1];\n      i = __read([t.p, e.p], 2), e.p = i[0], t.p = i[1];\n      e = t;\n    }\n    if (this.h.K === t) {\n      this.h.K = t.rr;\n    } else if (this.h.N === t) {\n      this.h.N = t.rr;\n    }\n    this.ue(t);\n    var n = t.rr;\n    if (t === n.K) {\n      n.K = undefined;\n    } else n.N = undefined;\n    this.M -= 1;\n    this.W.ee = 0;\n    return n;\n  };\n  TreeContainer.prototype.ae = function (e, r) {\n    if (e === undefined) return false;\n    var i = this.ae(e.K, r);\n    if (i) return true;\n    if (r(e)) return true;\n    return this.ae(e.N, r);\n  };\n  TreeContainer.prototype.fe = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r.ee === 0) return;\n      var i = r.rr;\n      if (r === i.K) {\n        var t = i.N;\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.N) {\n          e.ee = 0;\n          if (e.K) e.K.rr = r;\n          if (e.N) e.N.rr = i;\n          r.N = e.K;\n          i.K = e.N;\n          e.K = r;\n          e.N = i;\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n          if (i === this.W) {\n            this.W = i.te();\n          } else i.te();\n          i.ee = 1;\n        }\n      } else {\n        var t = i.K;\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.K) {\n          e.ee = 0;\n          if (e.K) e.K.rr = i;\n          if (e.N) e.N.rr = r;\n          i.N = e.K;\n          r.K = e.N;\n          e.K = i;\n          e.N = r;\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n          if (i === this.W) {\n            this.W = i.ne();\n          } else i.ne();\n          i.ee = 1;\n        }\n      }\n      return;\n    }\n  };\n  TreeContainer.prototype.se = function (e, r, i) {\n    if (this.W === undefined) {\n      this.M += 1;\n      this.W = new this.re(e, r);\n      this.W.ee = 0;\n      this.W.rr = this.h;\n      this.h.rr = this.W;\n      this.h.K = this.W;\n      this.h.N = this.W;\n      return;\n    }\n    var t;\n    var n = this.h.K;\n    var s = this.$(n.u, e);\n    if (s === 0) {\n      n.p = r;\n      return;\n    } else if (s > 0) {\n      n.K = new this.re(e, r);\n      n.K.rr = n;\n      t = n.K;\n      this.h.K = t;\n    } else {\n      var f = this.h.N;\n      var h = this.$(f.u, e);\n      if (h === 0) {\n        f.p = r;\n        return;\n      } else if (h < 0) {\n        f.N = new this.re(e, r);\n        f.N.rr = f;\n        t = f.N;\n        this.h.N = t;\n      } else {\n        if (i !== undefined) {\n          var u = i.o;\n          if (u !== this.h) {\n            var a = this.$(u.u, e);\n            if (a === 0) {\n              u.p = r;\n              return;\n            } else if (a > 0) {\n              var o = u.L();\n              var l = this.$(o.u, e);\n              if (l === 0) {\n                o.p = r;\n                return;\n              } else if (l < 0) {\n                t = new this.re(e, r);\n                if (o.N === undefined) {\n                  o.N = t;\n                  t.rr = o;\n                } else {\n                  u.K = t;\n                  t.rr = u;\n                }\n              }\n            }\n          }\n        }\n        if (t === undefined) {\n          t = this.W;\n          while (true) {\n            var v = this.$(t.u, e);\n            if (v > 0) {\n              if (t.K === undefined) {\n                t.K = new this.re(e, r);\n                t.K.rr = t;\n                t = t.K;\n                break;\n              }\n              t = t.K;\n            } else if (v < 0) {\n              if (t.N === undefined) {\n                t.N = new this.re(e, r);\n                t.N.rr = t;\n                t = t.N;\n                break;\n              }\n              t = t.N;\n            } else {\n              t.p = r;\n              return;\n            }\n          }\n        }\n      }\n    }\n    this.M += 1;\n    return t;\n  };\n  TreeContainer.prototype.g = function (e, r) {\n    while (e) {\n      var i = this.$(e.u, r);\n      if (i < 0) {\n        e = e.N;\n      } else if (i > 0) {\n        e = e.K;\n      } else return e;\n    }\n    return e || this.h;\n  };\n  TreeContainer.prototype.clear = function () {\n    this.M = 0;\n    this.W = undefined;\n    this.h.rr = undefined;\n    this.h.K = this.h.N = undefined;\n  };\n  TreeContainer.prototype.updateKeyByIterator = function (e, r) {\n    var i = e.o;\n    if (i === this.h) {\n      throwIteratorAccessError();\n    }\n    if (this.M === 1) {\n      i.u = r;\n      return true;\n    }\n    if (i === this.h.K) {\n      if (this.$(i.m().u, r) > 0) {\n        i.u = r;\n        return true;\n      }\n      return false;\n    }\n    if (i === this.h.N) {\n      if (this.$(i.L().u, r) < 0) {\n        i.u = r;\n        return true;\n      }\n      return false;\n    }\n    var t = i.L().u;\n    if (this.$(t, r) >= 0) return false;\n    var n = i.m().u;\n    if (this.$(n, r) <= 0) return false;\n    i.u = r;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (e) {\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n    var r = 0;\n    var i = this;\n    this.ae(this.W, function (t) {\n      if (e === r) {\n        i.G(t);\n        return true;\n      }\n      r += 1;\n      return false;\n    });\n    return this.M;\n  };\n  TreeContainer.prototype.eraseElementByKey = function (e) {\n    if (this.M === 0) return false;\n    var r = this.g(this.W, e);\n    if (r === this.h) return false;\n    this.G(r);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (e) {\n    var r = e.o;\n    if (r === this.h) {\n      throwIteratorAccessError();\n    }\n    var i = r.N === undefined;\n    var t = e.iteratorType === 0;\n    if (t) {\n      if (i) e.next();\n    } else {\n      if (!i || r.K === undefined) e.next();\n    }\n    this.G(r);\n    return e;\n  };\n  TreeContainer.prototype.forEach = function (e) {\n    var r, i;\n    var t = 0;\n    try {\n      for (var n = __values(this), s = n.next(); !s.done; s = n.next()) {\n        var f = s.value;\n        e(f, t++, this);\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (s && !s.done && (i = n.return)) i.call(n);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n  };\n  TreeContainer.prototype.getElementByPos = function (e) {\n    var r, i;\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n    var t;\n    var n = 0;\n    try {\n      for (var s = __values(this), f = s.next(); !f.done; f = s.next()) {\n        var h = f.value;\n        if (n === e) {\n          t = h;\n          break;\n        }\n        n += 1;\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (f && !f.done && (i = s.return)) i.call(s);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n    return t;\n  };\n  TreeContainer.prototype.getHeight = function () {\n    if (this.M === 0) return 0;\n    var traversal = function (e) {\n      if (!e) return 0;\n      return Math.max(traversal(e.K), traversal(e.N)) + 1;\n    };\n    return traversal(this.W);\n  };\n  return TreeContainer;\n}(Container);\nexport default TreeContainer;","map":{"version":3,"sources":["container/TreeContainer/Base/index.js","../../src/container/TreeContainer/Base/index.ts"],"names":["__extends","this","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__read","o","n","m","Symbol","iterator","i","r","ar","e","next","done","push","value","error","__values","s","length","_this","_a","_b","e_1","e_1_1","_c","return","e_2","e_2_1","TreeNode","TreeNodeEnableIndex","Container","throwIteratorAccessError","RangeError","undefined","x","y","_super","_cmp","cmp","enableIndex","_TreeNodeClass","_set","key","hint","curNode","_preSet","_parent","_header","_subTreeSize","nodeList","_insertNodeSelfBalance","parentNode","grandParent","curNode_1","_recount","_length","_eraseNode","_preEraseNode","TreeContainer","resNode","cmpResult","_key","_right","_left","_color","brother","_root","_rotateLeft","_rotateRight","clear","swapNode","_value","_eraseNodeSelfBalance","callback","ifReturn","_inOrderTraversal","uncle","GP","minNode","compareToMin","maxNode","compareToMax","iterNode","_node","iterCmpRes","preNode","_pre","preCmpRes","iter","node","_next","preKey","nextKey","pos","index","self","_findElementNode","hasNoRight","isNormal","iteratorType","element","res","traversal","Math","max"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = /** @class */ (function (_super) {\n    __extends(TreeContainer, _super);\n    /**\n     * @internal\n     */\n    function TreeContainer(cmp, enableIndex) {\n        if (cmp === void 0) { cmp = function (x, y) {\n            if (x < y)\n                return -1;\n            if (x > y)\n                return 1;\n            return 0;\n        }; }\n        if (enableIndex === void 0) { enableIndex = false; }\n        var _this = _super.call(this) || this;\n        /**\n         * @internal\n         */\n        _this._root = undefined;\n        _this._cmp = cmp;\n        if (enableIndex) {\n            _this._TreeNodeClass = TreeNodeEnableIndex;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode) {\n                    var p = curNode._parent;\n                    while (p !== this._header) {\n                        p._subTreeSize += 1;\n                        p = p._parent;\n                    }\n                    var nodeList = this._insertNodeSelfBalance(curNode);\n                    if (nodeList) {\n                        var _a = nodeList, parentNode = _a.parentNode, grandParent = _a.grandParent, curNode_1 = _a.curNode;\n                        parentNode._recount();\n                        grandParent._recount();\n                        curNode_1._recount();\n                    }\n                }\n                return this._length;\n            };\n            _this._eraseNode = function (curNode) {\n                var p = this._preEraseNode(curNode);\n                while (p !== this._header) {\n                    p._subTreeSize -= 1;\n                    p = p._parent;\n                }\n            };\n        }\n        else {\n            _this._TreeNodeClass = TreeNode;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode)\n                    this._insertNodeSelfBalance(curNode);\n                return this._length;\n            };\n            _this._eraseNode = _this._preEraseNode;\n        }\n        _this._header = new _this._TreeNodeClass();\n        return _this;\n    }\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._lowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._upperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                var brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                var brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preEraseNode = function (curNode) {\n        var _a, _b;\n        if (this._length === 1) {\n            this.clear();\n            return this._header;\n        }\n        var swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            _a = __read([swapNode._key, curNode._key], 2), curNode._key = _a[0], swapNode._key = _a[1];\n            _b = __read([swapNode._value, curNode._value], 2), curNode._value = _b[0], swapNode._value = _b[1];\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        var _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        return _parent;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._inOrderTraversal = function (curNode, callback) {\n        if (curNode === undefined)\n            return false;\n        var ifReturn = this._inOrderTraversal(curNode._left, callback);\n        if (ifReturn)\n            return true;\n        if (callback(curNode))\n            return true;\n        return this._inOrderTraversal(curNode._right, callback);\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            var grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                var uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = parentNode;\n                    if (curNode._right)\n                        curNode._right._parent = grandParent;\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            else {\n                var uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = grandParent;\n                    if (curNode._right)\n                        curNode._right._parent = parentNode;\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            return;\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preSet = function (key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value);\n            this._root._color = 0 /* TreeNodeColor.BLACK */;\n            this._root._parent = this._header;\n            this._header._parent = this._root;\n            this._header._left = this._root;\n            this._header._right = this._root;\n            return;\n        }\n        var curNode;\n        var minNode = this._header._left;\n        var compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            var maxNode = this._header._right;\n            var compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    var iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        var iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            var preNode = iterNode._pre();\n                            var preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        var cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this._length += 1;\n        return curNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._findElementNode = function (curNode, key) {\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    };\n    TreeContainer.prototype.clear = function () {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    };\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        if (node === this._header._left) {\n            if (this._cmp(node._next()._key, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (node === this._header._right) {\n            if (this._cmp(node._pre()._key, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        var preKey = node._pre()._key;\n        if (this._cmp(preKey, key) >= 0)\n            return false;\n        var nextKey = node._next()._key;\n        if (this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByPos = function (pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var index = 0;\n        var self = this;\n        this._inOrderTraversal(this._root, function (curNode) {\n            if (pos === index) {\n                self._eraseNode(curNode);\n                return true;\n            }\n            index += 1;\n            return false;\n        });\n        return this._length;\n    };\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    TreeContainer.prototype.eraseElementByKey = function (key) {\n        if (this._length === 0)\n            return false;\n        var curNode = this._findElementNode(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByIterator = function (iter) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        var hasNoRight = node._right === undefined;\n        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    };\n    TreeContainer.prototype.forEach = function (callback) {\n        var e_1, _a;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                callback(element, index++, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    TreeContainer.prototype.getElementByPos = function (pos) {\n        var e_2, _a;\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var res;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                if (index === pos) {\n                    res = element;\n                    break;\n                }\n                index += 1;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return res;\n    };\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    TreeContainer.prototype.getHeight = function () {\n        if (this._length === 0)\n            return 0;\n        var traversal = function (curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        };\n        return traversal(this._root);\n    };\n    return TreeContainer;\n}(Container));\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected readonly _eraseNode: (curNode: TreeNode<K, V>) => void;\n  /**\n   * @internal\n   */\n  protected _set: (key: K, value: V, hint?: TreeIterator<K, V>) => number;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    if (enableIndex) {\n      this._TreeNodeClass = TreeNodeEnableIndex;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) {\n          let p = curNode._parent as TreeNodeEnableIndex<K, V>;\n          while (p !== this._header) {\n            p._subTreeSize += 1;\n            p = p._parent as TreeNodeEnableIndex<K, V>;\n          }\n          const nodeList = this._insertNodeSelfBalance(curNode);\n          if (nodeList) {\n            const {\n              parentNode,\n              grandParent,\n              curNode\n            } = nodeList as unknown as Record<string, TreeNodeEnableIndex<K, V>>;\n            parentNode._recount();\n            grandParent._recount();\n            curNode._recount();\n          }\n        }\n        return this._length;\n      };\n      this._eraseNode = function (curNode) {\n        let p = this._preEraseNode(curNode) as TreeNodeEnableIndex<K, V>;\n        while (p !== this._header) {\n          p._subTreeSize -= 1;\n          p = p._parent as TreeNodeEnableIndex<K, V>;\n        }\n      };\n    } else {\n      this._TreeNodeClass = TreeNode;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) this._insertNodeSelfBalance(curNode);\n        return this._length;\n      };\n      this._eraseNode = this._preEraseNode;\n    }\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preEraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return this._header;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      [curNode._key, swapNode._key] = [swapNode._key, curNode._key];\n      [curNode._value, swapNode._value] = [swapNode._value, curNode._value];\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    const _parent = swapNode._parent!;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    return _parent;\n  }\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    curNode: TreeNode<K, V> | undefined,\n    callback: (curNode: TreeNode<K, V>) => boolean\n  ): boolean {\n    if (curNode === undefined) return false;\n    const ifReturn = this._inOrderTraversal(curNode._left, callback);\n    if (ifReturn) return true;\n    if (callback(curNode)) return true;\n    return this._inOrderTraversal(curNode._right, callback);\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = parentNode;\n          if (curNode._right) curNode._right._parent = grandParent;\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = grandParent;\n          if (curNode._right) curNode._right._parent = parentNode;\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preSet(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value);\n      this._root._color = TreeNodeColor.BLACK;\n      this._root._parent = this._header;\n      this._header._parent = this._root;\n      this._header._left = this._root;\n      this._header._right = this._root;\n      return;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return;\n            }\n          }\n        }\n      }\n    }\n    this._length += 1;\n    return curNode;\n  }\n  /**\n   * @internal\n   */\n  protected _findElementNode(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    if (node === this._header._left) {\n      if (this._cmp(node._next()._key!, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (node === this._header._right) {\n      if (this._cmp(node._pre()._key!, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (this._cmp(preKey, key) >= 0) return false;\n    const nextKey = node._next()._key!;\n    if (this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let index = 0;\n    const self = this;\n    this._inOrderTraversal(\n      this._root,\n      function (curNode) {\n        if (pos === index) {\n          self._eraseNode(curNode);\n          return true;\n        }\n        index += 1;\n        return false;\n      });\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._findElementNode(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  forEach(callback: (element: K | [K, V], index: number, tree: TreeContainer<K, V>) => void) {\n    let index = 0;\n    for (const element of this) callback(element, index++, this);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let res;\n    let index = 0;\n    for (const element of this) {\n      if (index === pos) {\n        res = element;\n        break;\n      }\n      index += 1;\n    }\n    return <K | [K, V]>res;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    const traversal =\n      function (curNode: TreeNode<K, V> | undefined): number {\n        if (!curNode) return 0;\n        return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n      };\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"]},"metadata":{},"sourceType":"module"}