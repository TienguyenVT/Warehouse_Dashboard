{"ast":null,"code":"// Giả lập MQTT Client thay vì kết nối thực tế\nclass MockMQTTClient {\n  constructor() {\n    this.topics = new Map();\n    this.isConnected = true;\n    console.log('Sử dụng Mock MQTT Client thay vì kết nối thực tế');\n  }\n  async connect() {\n    // Không cần kết nối thực sự\n    console.log('Mock MQTT: Giả lập kết nối thành công');\n    return Promise.resolve();\n  }\n  async subscribe(topic, handler) {\n    console.log(`Mock MQTT: Subscribe to topic ${topic}`);\n    if (!this.topics.has(topic)) {\n      this.topics.set(topic, []);\n    }\n    const handlers = this.topics.get(topic);\n    handlers.push(handler);\n    this.topics.set(topic, handlers);\n\n    // Giả lập dữ liệu ban đầu sau 1 giây\n    setTimeout(() => {\n      this.simulateInitialData(topic);\n    }, 1000);\n\n    // Thiết lập cập nhật ngẫu nhiên mỗi 10 giây\n    const intervalId = setInterval(() => {\n      this.simulateRandomUpdate(topic);\n    }, 10000);\n\n    // Trả về hàm unsubscribe\n    return () => {\n      console.log(`Mock MQTT: Unsubscribe from topic ${topic}`);\n      const handlers = this.topics.get(topic);\n      if (handlers) {\n        const updatedHandlers = handlers.filter(h => h !== handler);\n        if (updatedHandlers.length === 0) {\n          this.topics.delete(topic);\n          // Xóa interval khi không còn handler nào\n          clearInterval(intervalId);\n        } else {\n          this.topics.set(topic, updatedHandlers);\n        }\n      }\n    };\n  }\n  async publish(topic, message) {\n    console.log(`Mock MQTT: Publishing to ${topic}`, message);\n\n    // Giả lập xử lý message đã được publish\n    setTimeout(() => {\n      const handlers = this.topics.get(topic) || [];\n      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n      handlers.forEach(handler => {\n        handler({\n          ...JSON.parse(messageStr),\n          topic\n        });\n      });\n    }, 500);\n    return Promise.resolve();\n  }\n\n  // Phương thức giả lập dữ liệu ban đầu\n  simulateInitialData(topicPattern) {\n    if (topicPattern === 'warehouse/shelf/#') {\n      // Tạo dữ liệu cho tất cả các kệ\n      for (let tier = 1; tier <= 3; tier++) {\n        for (let tray = 1; tray <= 5; tray++) {\n          const topic = `warehouse/shelf/${tier}/${tray}/status`;\n          const data = this.generateShelfData(tier, tray);\n          const handlers = this.topics.get(topicPattern) || [];\n          handlers.forEach(handler => {\n            handler({\n              ...data,\n              topic\n            });\n          });\n        }\n      }\n    }\n  }\n\n  // Phương thức giả lập cập nhật ngẫu nhiên\n  simulateRandomUpdate(topicPattern) {\n    if (topicPattern === 'warehouse/shelf/#' && Math.random() < 0.5) {\n      // Chọn ngẫu nhiên một kệ để cập nhật\n      const tier = Math.floor(Math.random() * 3) + 1;\n      const tray = Math.floor(Math.random() * 5) + 1;\n      const topic = `warehouse/shelf/${tier}/${tray}/status`;\n      const data = this.generateShelfData(tier, tray);\n      const handlers = this.topics.get(topicPattern) || [];\n      handlers.forEach(handler => {\n        handler({\n          ...data,\n          topic\n        });\n      });\n    }\n  }\n\n  // Tạo dữ liệu ngẫu nhiên cho kệ\n  generateShelfData(tier, tray) {\n    const capacity = Math.floor(Math.random() * 101);\n    let status;\n    if (capacity >= 80) status = 'HIGH';else if (capacity >= 30) status = 'MEDIUM';else status = 'EMPTY';\n    return {\n      tier,\n      tray,\n      status,\n      capacity,\n      lastUpdated: new Date().toISOString()\n    };\n  }\n}\n\n// Tạo và xuất instance singleton\nconst mqttClient = new MockMQTTClient();\nexport { mqttClient };","map":{"version":3,"names":["MockMQTTClient","constructor","topics","Map","isConnected","console","log","connect","Promise","resolve","subscribe","topic","handler","has","set","handlers","get","push","setTimeout","simulateInitialData","intervalId","setInterval","simulateRandomUpdate","updatedHandlers","filter","h","length","delete","clearInterval","publish","message","messageStr","JSON","stringify","forEach","parse","topicPattern","tier","tray","data","generateShelfData","Math","random","floor","capacity","status","lastUpdated","Date","toISOString","mqttClient"],"sources":["C:/Documents/warehouse-dashboard/src/utils/mqtt.js"],"sourcesContent":["// Giả lập MQTT Client thay vì kết nối thực tế\r\nclass MockMQTTClient {\r\n  constructor() {\r\n    this.topics = new Map();\r\n    this.isConnected = true;\r\n    console.log('Sử dụng Mock MQTT Client thay vì kết nối thực tế');\r\n  }\r\n\r\n  async connect() {\r\n    // Không cần kết nối thực sự\r\n    console.log('Mock MQTT: Giả lập kết nối thành công');\r\n    return Promise.resolve();\r\n  }\r\n\r\n  async subscribe(topic, handler) {\r\n    console.log(`Mock MQTT: Subscribe to topic ${topic}`);\r\n    \r\n    if (!this.topics.has(topic)) {\r\n      this.topics.set(topic, []);\r\n    }\r\n\r\n    const handlers = this.topics.get(topic);\r\n    handlers.push(handler);\r\n    this.topics.set(topic, handlers);\r\n\r\n    // Giả lập dữ liệu ban đầu sau 1 giây\r\n    setTimeout(() => {\r\n      this.simulateInitialData(topic);\r\n    }, 1000);\r\n\r\n    // Thiết lập cập nhật ngẫu nhiên mỗi 10 giây\r\n    const intervalId = setInterval(() => {\r\n      this.simulateRandomUpdate(topic);\r\n    }, 10000);\r\n\r\n    // Trả về hàm unsubscribe\r\n    return () => {\r\n      console.log(`Mock MQTT: Unsubscribe from topic ${topic}`);\r\n      const handlers = this.topics.get(topic);\r\n      if (handlers) {\r\n        const updatedHandlers = handlers.filter(h => h !== handler);\r\n        if (updatedHandlers.length === 0) {\r\n          this.topics.delete(topic);\r\n          // Xóa interval khi không còn handler nào\r\n          clearInterval(intervalId);\r\n        } else {\r\n          this.topics.set(topic, updatedHandlers);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  async publish(topic, message) {\r\n    console.log(`Mock MQTT: Publishing to ${topic}`, message);\r\n    \r\n    // Giả lập xử lý message đã được publish\r\n    setTimeout(() => {\r\n      const handlers = this.topics.get(topic) || [];\r\n      const messageStr = typeof message === 'string' \r\n        ? message \r\n        : JSON.stringify(message);\r\n      \r\n      handlers.forEach(handler => {\r\n        handler({\r\n          ...JSON.parse(messageStr),\r\n          topic\r\n        });\r\n      });\r\n    }, 500);\r\n\r\n    return Promise.resolve();\r\n  }\r\n\r\n  // Phương thức giả lập dữ liệu ban đầu\r\n  simulateInitialData(topicPattern) {\r\n    if (topicPattern === 'warehouse/shelf/#') {\r\n      // Tạo dữ liệu cho tất cả các kệ\r\n      for (let tier = 1; tier <= 3; tier++) {\r\n        for (let tray = 1; tray <= 5; tray++) {\r\n          const topic = `warehouse/shelf/${tier}/${tray}/status`;\r\n          const data = this.generateShelfData(tier, tray);\r\n          \r\n          const handlers = this.topics.get(topicPattern) || [];\r\n          handlers.forEach(handler => {\r\n            handler({\r\n              ...data,\r\n              topic\r\n            });\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Phương thức giả lập cập nhật ngẫu nhiên\r\n  simulateRandomUpdate(topicPattern) {\r\n    if (topicPattern === 'warehouse/shelf/#' && Math.random() < 0.5) {\r\n      // Chọn ngẫu nhiên một kệ để cập nhật\r\n      const tier = Math.floor(Math.random() * 3) + 1;\r\n      const tray = Math.floor(Math.random() * 5) + 1;\r\n      const topic = `warehouse/shelf/${tier}/${tray}/status`;\r\n      const data = this.generateShelfData(tier, tray);\r\n      \r\n      const handlers = this.topics.get(topicPattern) || [];\r\n      handlers.forEach(handler => {\r\n        handler({\r\n          ...data,\r\n          topic\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // Tạo dữ liệu ngẫu nhiên cho kệ\r\n  generateShelfData(tier, tray) {\r\n    const capacity = Math.floor(Math.random() * 101);\r\n    let status;\r\n    if (capacity >= 80) status = 'HIGH';\r\n    else if (capacity >= 30) status = 'MEDIUM';\r\n    else status = 'EMPTY';\r\n    \r\n    return {\r\n      tier,\r\n      tray,\r\n      status,\r\n      capacity,\r\n      lastUpdated: new Date().toISOString()\r\n    };\r\n  }\r\n}\r\n\r\n// Tạo và xuất instance singleton\r\nconst mqttClient = new MockMQTTClient();\r\nexport { mqttClient };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}