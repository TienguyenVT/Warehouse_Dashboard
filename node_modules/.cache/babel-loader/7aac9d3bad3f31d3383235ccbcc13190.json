{"ast":null,"code":"// Giả lập MQTT Client thay vì kết nối thực tế\nclass MockMQTTClient {\n  constructor() {\n    this.topics = new Map();\n    this.isConnected = true;\n    console.log('Sử dụng Mock MQTT Client thay vì kết nối thực tế');\n  }\n  async connect() {\n    // Không cần kết nối thực sự\n    console.log('Mock MQTT: Giả lập kết nối thành công');\n    return Promise.resolve();\n  }\n  async subscribe(topic, handler) {\n    console.log(`Mock MQTT: Subscribe to topic ${topic}`);\n    if (!this.topics.has(topic)) {\n      this.topics.set(topic, []);\n    }\n    const handlers = this.topics.get(topic);\n    handlers.push(handler);\n    this.topics.set(topic, handlers);\n\n    // Giả lập dữ liệu ban đầu sau 1 giây\n    setTimeout(() => {\n      this.simulateInitialData(topic);\n    }, 1000);\n\n    // Thiết lập cập nhật ngẫu nhiên mỗi 10 giây\n    const intervalId = setInterval(() => {\n      this.simulateRandomUpdate(topic);\n    }, 10000);\n\n    // Trả về hàm unsubscribe\n    return () => {\n      console.log(`Mock MQTT: Unsubscribe from topic ${topic}`);\n      const handlers = this.topics.get(topic);\n      if (handlers) {\n        const updatedHandlers = handlers.filter(h => h !== handler);\n        if (updatedHandlers.length === 0) {\n          this.topics.delete(topic);\n          // Xóa interval khi không còn handler nào\n          clearInterval(intervalId);\n        } else {\n          this.topics.set(topic, updatedHandlers);\n        }\n      }\n    };\n  }\n  async publish(topic, message) {\n    console.log(`Mock MQTT: Publishing to ${topic}`, message);\n\n    // Giả lập xử lý message đã được publish\n    setTimeout(() => {\n      const handlers = this.topics.get(topic) || [];\n      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n      handlers.forEach(handler => {\n        handler({\n          ...JSON.parse(messageStr),\n          topic\n        });\n      });\n    }, 500);\n    return Promise.resolve();\n  }\n\n  // Phương thức giả lập dữ liệu ban đầu\n  simulateInitialData(topicPattern) {\n    if (topicPattern === 'warehouse/shelf/#') {\n      // Tạo dữ liệu cho tất cả các kệ\n      for (let tier = 1; tier <= 3; tier++) {\n        for (let tray = 1; tray <= 5; tray++) {\n          const topic = `warehouse/shelf/${tier}/${tray}/status`;\n          const data = this.generateShelfData(tier, tray);\n          const handlers = this.topics.get(topicPattern) || [];\n          handlers.forEach(handler => {\n            handler({\n              ...data,\n              topic\n            });\n          });\n        }\n      }\n    }\n  }\n\n  // Phương thức giả lập cập nhật ngẫu nhiên\n  simulateRandomUpdate(topicPattern) {\n    if (topicPattern === 'warehouse/shelf/#' && Math.random() < 0.5) {\n      // Chọn ngẫu nhiên một kệ để cập nhật\n      const tier = Math.floor(Math.random() * 3) + 1;\n      const tray = Math.floor(Math.random() * 5) + 1;\n      const topic = `warehouse/shelf/${tier}/${tray}/status`;\n      const data = this.generateShelfData(tier, tray);\n      const handlers = this.topics.get(topicPattern) || [];\n      handlers.forEach(handler => {\n        handler({\n          ...data,\n          topic\n        });\n      });\n    }\n  }\n\n  // Tạo dữ liệu ngẫu nhiên cho kệ\n  generateShelfData(tier, tray) {\n    const capacity = Math.floor(Math.random() * 101);\n    let status;\n    if (capacity >= 80) status = 'HIGH';else if (capacity >= 30) status = 'MEDIUM';else status = 'EMPTY';\n    return {\n      tier,\n      tray,\n      status,\n      capacity,\n      lastUpdated: new Date().toISOString()\n    };\n  }\n}\n\n// Tạo và xuất instance singleton\nconst mqttClient = new MockMQTTClient();\nexport { mqttClient };\n\n// Các hằng số cấu hình MQTT\nconst MQTT_BROKER_URL = 'ws://localhost:9001'; // WebSocket port cho Mosquitto\nconst MQTT_TOPIC = 'warehouse/shelves/updates';\nlet client = null;\nlet messageCallbacks = new Set();\nlet mockInterval;\n\n// Mock updates cho development (khi không có MQTT broker)\nconst createMockUpdates = callback => {\n  // Giả lập cập nhật ngẫu nhiên mỗi 10 giây\n  mockInterval = setInterval(() => {\n    const mockUpdate = {\n      tier: Math.floor(Math.random() * 3) + 1,\n      tray: Math.floor(Math.random() * 4) + 1,\n      itemCount: Math.floor(Math.random() * 100),\n      status: ['HIGH', 'MEDIUM', 'EMPTY'][Math.floor(Math.random() * 3)],\n      lastUpdated: new Date().toISOString()\n    };\n    callback(mockUpdate);\n  }, 10000);\n  return () => {\n    if (mockInterval) {\n      clearInterval(mockInterval);\n    }\n  };\n};\n\n// Khởi tạo kết nối MQTT\nconst initializeMQTTClient = async () => {\n  if (typeof window !== 'undefined' && !client) {\n    try {\n      // Dynamic import của thư viện MQTT\n      const mqtt = await import('mqtt');\n      client = mqtt.connect(MQTT_BROKER_URL);\n      client.on('connect', () => {\n        console.log('Connected to MQTT broker');\n        client.subscribe(MQTT_TOPIC);\n      });\n      client.on('message', (topic, message) => {\n        try {\n          const update = JSON.parse(message.toString());\n          messageCallbacks.forEach(callback => callback(update));\n        } catch (error) {\n          console.error('Error processing MQTT message:', error);\n        }\n      });\n      client.on('error', error => {\n        console.error('MQTT connection error:', error);\n      });\n    } catch (error) {\n      console.error('Failed to initialize MQTT client:', error);\n      // Fallback to mock updates in case of error\n      return createMockUpdates;\n    }\n  }\n};\n\n// Subscribe để nhận cập nhật kệ hàng\nconst subscribeToShelfUpdates = callback => {\n  // Trong môi trường development hoặc khi không có MQTT, sử dụng mock\n  if (process.env.NODE_ENV === 'development') {\n    console.log('Using mock MQTT updates for development');\n    return createMockUpdates(callback);\n  }\n\n  // Trong production, sử dụng MQTT thật\n  if (!client) {\n    initializeMQTTClient();\n  }\n  messageCallbacks.add(callback);\n\n  // Trả về hàm cleanup\n  return () => {\n    messageCallbacks.delete(callback);\n    if (messageCallbacks.size === 0 && client) {\n      client.end();\n      client = null;\n    }\n  };\n};\nexport { subscribeToShelfUpdates };","map":{"version":3,"names":["MockMQTTClient","constructor","topics","Map","isConnected","console","log","connect","Promise","resolve","subscribe","topic","handler","has","set","handlers","get","push","setTimeout","simulateInitialData","intervalId","setInterval","simulateRandomUpdate","updatedHandlers","filter","h","length","delete","clearInterval","publish","message","messageStr","JSON","stringify","forEach","parse","topicPattern","tier","tray","data","generateShelfData","Math","random","floor","capacity","status","lastUpdated","Date","toISOString","mqttClient","MQTT_BROKER_URL","MQTT_TOPIC","client","messageCallbacks","Set","mockInterval","createMockUpdates","callback","mockUpdate","itemCount","initializeMQTTClient","window","mqtt","on","update","toString","error","subscribeToShelfUpdates","process","env","NODE_ENV","add","size","end"],"sources":["C:/Documents/warehouse-dashboard/src/utils/mqtt.js"],"sourcesContent":["// Giả lập MQTT Client thay vì kết nối thực tế\r\nclass MockMQTTClient {\r\n  constructor() {\r\n    this.topics = new Map();\r\n    this.isConnected = true;\r\n    console.log('Sử dụng Mock MQTT Client thay vì kết nối thực tế');\r\n  }\r\n\r\n  async connect() {\r\n    // Không cần kết nối thực sự\r\n    console.log('Mock MQTT: Giả lập kết nối thành công');\r\n    return Promise.resolve();\r\n  }\r\n\r\n  async subscribe(topic, handler) {\r\n    console.log(`Mock MQTT: Subscribe to topic ${topic}`);\r\n    \r\n    if (!this.topics.has(topic)) {\r\n      this.topics.set(topic, []);\r\n    }\r\n\r\n    const handlers = this.topics.get(topic);\r\n    handlers.push(handler);\r\n    this.topics.set(topic, handlers);\r\n\r\n    // Giả lập dữ liệu ban đầu sau 1 giây\r\n    setTimeout(() => {\r\n      this.simulateInitialData(topic);\r\n    }, 1000);\r\n\r\n    // Thiết lập cập nhật ngẫu nhiên mỗi 10 giây\r\n    const intervalId = setInterval(() => {\r\n      this.simulateRandomUpdate(topic);\r\n    }, 10000);\r\n\r\n    // Trả về hàm unsubscribe\r\n    return () => {\r\n      console.log(`Mock MQTT: Unsubscribe from topic ${topic}`);\r\n      const handlers = this.topics.get(topic);\r\n      if (handlers) {\r\n        const updatedHandlers = handlers.filter(h => h !== handler);\r\n        if (updatedHandlers.length === 0) {\r\n          this.topics.delete(topic);\r\n          // Xóa interval khi không còn handler nào\r\n          clearInterval(intervalId);\r\n        } else {\r\n          this.topics.set(topic, updatedHandlers);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  async publish(topic, message) {\r\n    console.log(`Mock MQTT: Publishing to ${topic}`, message);\r\n    \r\n    // Giả lập xử lý message đã được publish\r\n    setTimeout(() => {\r\n      const handlers = this.topics.get(topic) || [];\r\n      const messageStr = typeof message === 'string' \r\n        ? message \r\n        : JSON.stringify(message);\r\n      \r\n      handlers.forEach(handler => {\r\n        handler({\r\n          ...JSON.parse(messageStr),\r\n          topic\r\n        });\r\n      });\r\n    }, 500);\r\n\r\n    return Promise.resolve();\r\n  }\r\n\r\n  // Phương thức giả lập dữ liệu ban đầu\r\n  simulateInitialData(topicPattern) {\r\n    if (topicPattern === 'warehouse/shelf/#') {\r\n      // Tạo dữ liệu cho tất cả các kệ\r\n      for (let tier = 1; tier <= 3; tier++) {\r\n        for (let tray = 1; tray <= 5; tray++) {\r\n          const topic = `warehouse/shelf/${tier}/${tray}/status`;\r\n          const data = this.generateShelfData(tier, tray);\r\n          \r\n          const handlers = this.topics.get(topicPattern) || [];\r\n          handlers.forEach(handler => {\r\n            handler({\r\n              ...data,\r\n              topic\r\n            });\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Phương thức giả lập cập nhật ngẫu nhiên\r\n  simulateRandomUpdate(topicPattern) {\r\n    if (topicPattern === 'warehouse/shelf/#' && Math.random() < 0.5) {\r\n      // Chọn ngẫu nhiên một kệ để cập nhật\r\n      const tier = Math.floor(Math.random() * 3) + 1;\r\n      const tray = Math.floor(Math.random() * 5) + 1;\r\n      const topic = `warehouse/shelf/${tier}/${tray}/status`;\r\n      const data = this.generateShelfData(tier, tray);\r\n      \r\n      const handlers = this.topics.get(topicPattern) || [];\r\n      handlers.forEach(handler => {\r\n        handler({\r\n          ...data,\r\n          topic\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // Tạo dữ liệu ngẫu nhiên cho kệ\r\n  generateShelfData(tier, tray) {\r\n    const capacity = Math.floor(Math.random() * 101);\r\n    let status;\r\n    if (capacity >= 80) status = 'HIGH';\r\n    else if (capacity >= 30) status = 'MEDIUM';\r\n    else status = 'EMPTY';\r\n    \r\n    return {\r\n      tier,\r\n      tray,\r\n      status,\r\n      capacity,\r\n      lastUpdated: new Date().toISOString()\r\n    };\r\n  }\r\n}\r\n\r\n// Tạo và xuất instance singleton\r\nconst mqttClient = new MockMQTTClient();\r\nexport { mqttClient };\r\n\r\n// Các hằng số cấu hình MQTT\r\nconst MQTT_BROKER_URL = 'ws://localhost:9001'; // WebSocket port cho Mosquitto\r\nconst MQTT_TOPIC = 'warehouse/shelves/updates';\r\n\r\nlet client = null;\r\nlet messageCallbacks = new Set();\r\nlet mockInterval;\r\n\r\n// Mock updates cho development (khi không có MQTT broker)\r\nconst createMockUpdates = (callback) => {\r\n    // Giả lập cập nhật ngẫu nhiên mỗi 10 giây\r\n    mockInterval = setInterval(() => {\r\n        const mockUpdate = {\r\n            tier: Math.floor(Math.random() * 3) + 1,\r\n            tray: Math.floor(Math.random() * 4) + 1,\r\n            itemCount: Math.floor(Math.random() * 100),\r\n            status: ['HIGH', 'MEDIUM', 'EMPTY'][Math.floor(Math.random() * 3)],\r\n            lastUpdated: new Date().toISOString()\r\n        };\r\n        callback(mockUpdate);\r\n    }, 10000);\r\n\r\n    return () => {\r\n        if (mockInterval) {\r\n            clearInterval(mockInterval);\r\n        }\r\n    };\r\n};\r\n\r\n// Khởi tạo kết nối MQTT\r\nconst initializeMQTTClient = async () => {\r\n    if (typeof window !== 'undefined' && !client) {\r\n        try {\r\n            // Dynamic import của thư viện MQTT\r\n            const mqtt = await import('mqtt');\r\n            client = mqtt.connect(MQTT_BROKER_URL);\r\n\r\n            client.on('connect', () => {\r\n                console.log('Connected to MQTT broker');\r\n                client.subscribe(MQTT_TOPIC);\r\n            });\r\n\r\n            client.on('message', (topic, message) => {\r\n                try {\r\n                    const update = JSON.parse(message.toString());\r\n                    messageCallbacks.forEach(callback => callback(update));\r\n                } catch (error) {\r\n                    console.error('Error processing MQTT message:', error);\r\n                }\r\n            });\r\n\r\n            client.on('error', (error) => {\r\n                console.error('MQTT connection error:', error);\r\n            });\r\n        } catch (error) {\r\n            console.error('Failed to initialize MQTT client:', error);\r\n            // Fallback to mock updates in case of error\r\n            return createMockUpdates;\r\n        }\r\n    }\r\n};\r\n\r\n// Subscribe để nhận cập nhật kệ hàng\r\nconst subscribeToShelfUpdates = (callback) => {\r\n    // Trong môi trường development hoặc khi không có MQTT, sử dụng mock\r\n    if (process.env.NODE_ENV === 'development') {\r\n        console.log('Using mock MQTT updates for development');\r\n        return createMockUpdates(callback);\r\n    }\r\n\r\n    // Trong production, sử dụng MQTT thật\r\n    if (!client) {\r\n        initializeMQTTClient();\r\n    }\r\n\r\n    messageCallbacks.add(callback);\r\n\r\n    // Trả về hàm cleanup\r\n    return () => {\r\n        messageCallbacks.delete(callback);\r\n        if (messageCallbacks.size === 0 && client) {\r\n            client.end();\r\n            client = null;\r\n        }\r\n    };\r\n};\r\n\r\nexport { subscribeToShelfUpdates };\r\n"],"mappings":"AAAA;AACA,MAAMA,cAAc,CAAC;EACnBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvBC,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;EACjE;EAEA,MAAMC,OAAOA,CAAA,EAAG;IACd;IACAF,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;IACpD,OAAOE,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1B;EAEA,MAAMC,SAASA,CAACC,KAAK,EAAEC,OAAO,EAAE;IAC9BP,OAAO,CAACC,GAAG,CAAC,iCAAiCK,KAAK,EAAE,CAAC;IAErD,IAAI,CAAC,IAAI,CAACT,MAAM,CAACW,GAAG,CAACF,KAAK,CAAC,EAAE;MAC3B,IAAI,CAACT,MAAM,CAACY,GAAG,CAACH,KAAK,EAAE,EAAE,CAAC;IAC5B;IAEA,MAAMI,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAACL,KAAK,CAAC;IACvCI,QAAQ,CAACE,IAAI,CAACL,OAAO,CAAC;IACtB,IAAI,CAACV,MAAM,CAACY,GAAG,CAACH,KAAK,EAAEI,QAAQ,CAAC;;IAEhC;IACAG,UAAU,CAAC,MAAM;MACf,IAAI,CAACC,mBAAmB,CAACR,KAAK,CAAC;IACjC,CAAC,EAAE,IAAI,CAAC;;IAER;IACA,MAAMS,UAAU,GAAGC,WAAW,CAAC,MAAM;MACnC,IAAI,CAACC,oBAAoB,CAACX,KAAK,CAAC;IAClC,CAAC,EAAE,KAAK,CAAC;;IAET;IACA,OAAO,MAAM;MACXN,OAAO,CAACC,GAAG,CAAC,qCAAqCK,KAAK,EAAE,CAAC;MACzD,MAAMI,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAACL,KAAK,CAAC;MACvC,IAAII,QAAQ,EAAE;QACZ,MAAMQ,eAAe,GAAGR,QAAQ,CAACS,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKb,OAAO,CAAC;QAC3D,IAAIW,eAAe,CAACG,MAAM,KAAK,CAAC,EAAE;UAChC,IAAI,CAACxB,MAAM,CAACyB,MAAM,CAAChB,KAAK,CAAC;UACzB;UACAiB,aAAa,CAACR,UAAU,CAAC;QAC3B,CAAC,MAAM;UACL,IAAI,CAAClB,MAAM,CAACY,GAAG,CAACH,KAAK,EAAEY,eAAe,CAAC;QACzC;MACF;IACF,CAAC;EACH;EAEA,MAAMM,OAAOA,CAAClB,KAAK,EAAEmB,OAAO,EAAE;IAC5BzB,OAAO,CAACC,GAAG,CAAC,4BAA4BK,KAAK,EAAE,EAAEmB,OAAO,CAAC;;IAEzD;IACAZ,UAAU,CAAC,MAAM;MACf,MAAMH,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAACL,KAAK,CAAC,IAAI,EAAE;MAC7C,MAAMoB,UAAU,GAAG,OAAOD,OAAO,KAAK,QAAQ,GAC1CA,OAAO,GACPE,IAAI,CAACC,SAAS,CAACH,OAAO,CAAC;MAE3Bf,QAAQ,CAACmB,OAAO,CAACtB,OAAO,IAAI;QAC1BA,OAAO,CAAC;UACN,GAAGoB,IAAI,CAACG,KAAK,CAACJ,UAAU,CAAC;UACzBpB;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,EAAE,GAAG,CAAC;IAEP,OAAOH,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1B;;EAEA;EACAU,mBAAmBA,CAACiB,YAAY,EAAE;IAChC,IAAIA,YAAY,KAAK,mBAAmB,EAAE;MACxC;MACA,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAI,CAAC,EAAEA,IAAI,EAAE,EAAE;QACpC,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAI,CAAC,EAAEA,IAAI,EAAE,EAAE;UACpC,MAAM3B,KAAK,GAAG,mBAAmB0B,IAAI,IAAIC,IAAI,SAAS;UACtD,MAAMC,IAAI,GAAG,IAAI,CAACC,iBAAiB,CAACH,IAAI,EAAEC,IAAI,CAAC;UAE/C,MAAMvB,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAACoB,YAAY,CAAC,IAAI,EAAE;UACpDrB,QAAQ,CAACmB,OAAO,CAACtB,OAAO,IAAI;YAC1BA,OAAO,CAAC;cACN,GAAG2B,IAAI;cACP5B;YACF,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;MACF;IACF;EACF;;EAEA;EACAW,oBAAoBA,CAACc,YAAY,EAAE;IACjC,IAAIA,YAAY,KAAK,mBAAmB,IAAIK,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,EAAE;MAC/D;MACA,MAAML,IAAI,GAAGI,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MAC9C,MAAMJ,IAAI,GAAGG,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MAC9C,MAAM/B,KAAK,GAAG,mBAAmB0B,IAAI,IAAIC,IAAI,SAAS;MACtD,MAAMC,IAAI,GAAG,IAAI,CAACC,iBAAiB,CAACH,IAAI,EAAEC,IAAI,CAAC;MAE/C,MAAMvB,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAACoB,YAAY,CAAC,IAAI,EAAE;MACpDrB,QAAQ,CAACmB,OAAO,CAACtB,OAAO,IAAI;QAC1BA,OAAO,CAAC;UACN,GAAG2B,IAAI;UACP5B;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;EACF;;EAEA;EACA6B,iBAAiBA,CAACH,IAAI,EAAEC,IAAI,EAAE;IAC5B,MAAMM,QAAQ,GAAGH,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IAChD,IAAIG,MAAM;IACV,IAAID,QAAQ,IAAI,EAAE,EAAEC,MAAM,GAAG,MAAM,CAAC,KAC/B,IAAID,QAAQ,IAAI,EAAE,EAAEC,MAAM,GAAG,QAAQ,CAAC,KACtCA,MAAM,GAAG,OAAO;IAErB,OAAO;MACLR,IAAI;MACJC,IAAI;MACJO,MAAM;MACND,QAAQ;MACRE,WAAW,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACtC,CAAC;EACH;AACF;;AAEA;AACA,MAAMC,UAAU,GAAG,IAAIjD,cAAc,CAAC,CAAC;AACvC,SAASiD,UAAU;;AAEnB;AACA,MAAMC,eAAe,GAAG,qBAAqB,CAAC,CAAC;AAC/C,MAAMC,UAAU,GAAG,2BAA2B;AAE9C,IAAIC,MAAM,GAAG,IAAI;AACjB,IAAIC,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAAC;AAChC,IAAIC,YAAY;;AAEhB;AACA,MAAMC,iBAAiB,GAAIC,QAAQ,IAAK;EACpC;EACAF,YAAY,GAAGlC,WAAW,CAAC,MAAM;IAC7B,MAAMqC,UAAU,GAAG;MACfrB,IAAI,EAAEI,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACvCJ,IAAI,EAAEG,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACvCiB,SAAS,EAAElB,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;MAC1CG,MAAM,EAAE,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAACJ,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;MAClEI,WAAW,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACxC,CAAC;IACDS,QAAQ,CAACC,UAAU,CAAC;EACxB,CAAC,EAAE,KAAK,CAAC;EAET,OAAO,MAAM;IACT,IAAIH,YAAY,EAAE;MACd3B,aAAa,CAAC2B,YAAY,CAAC;IAC/B;EACJ,CAAC;AACL,CAAC;;AAED;AACA,MAAMK,oBAAoB,GAAG,MAAAA,CAAA,KAAY;EACrC,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAI,CAACT,MAAM,EAAE;IAC1C,IAAI;MACA;MACA,MAAMU,IAAI,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC;MACjCV,MAAM,GAAGU,IAAI,CAACvD,OAAO,CAAC2C,eAAe,CAAC;MAEtCE,MAAM,CAACW,EAAE,CAAC,SAAS,EAAE,MAAM;QACvB1D,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;QACvC8C,MAAM,CAAC1C,SAAS,CAACyC,UAAU,CAAC;MAChC,CAAC,CAAC;MAEFC,MAAM,CAACW,EAAE,CAAC,SAAS,EAAE,CAACpD,KAAK,EAAEmB,OAAO,KAAK;QACrC,IAAI;UACA,MAAMkC,MAAM,GAAGhC,IAAI,CAACG,KAAK,CAACL,OAAO,CAACmC,QAAQ,CAAC,CAAC,CAAC;UAC7CZ,gBAAgB,CAACnB,OAAO,CAACuB,QAAQ,IAAIA,QAAQ,CAACO,MAAM,CAAC,CAAC;QAC1D,CAAC,CAAC,OAAOE,KAAK,EAAE;UACZ7D,OAAO,CAAC6D,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;QAC1D;MACJ,CAAC,CAAC;MAEFd,MAAM,CAACW,EAAE,CAAC,OAAO,EAAGG,KAAK,IAAK;QAC1B7D,OAAO,CAAC6D,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAClD,CAAC,CAAC;IACN,CAAC,CAAC,OAAOA,KAAK,EAAE;MACZ7D,OAAO,CAAC6D,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD;MACA,OAAOV,iBAAiB;IAC5B;EACJ;AACJ,CAAC;;AAED;AACA,MAAMW,uBAAuB,GAAIV,QAAQ,IAAK;EAC1C;EACA,IAAIW,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IACxCjE,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;IACtD,OAAOkD,iBAAiB,CAACC,QAAQ,CAAC;EACtC;;EAEA;EACA,IAAI,CAACL,MAAM,EAAE;IACTQ,oBAAoB,CAAC,CAAC;EAC1B;EAEAP,gBAAgB,CAACkB,GAAG,CAACd,QAAQ,CAAC;;EAE9B;EACA,OAAO,MAAM;IACTJ,gBAAgB,CAAC1B,MAAM,CAAC8B,QAAQ,CAAC;IACjC,IAAIJ,gBAAgB,CAACmB,IAAI,KAAK,CAAC,IAAIpB,MAAM,EAAE;MACvCA,MAAM,CAACqB,GAAG,CAAC,CAAC;MACZrB,MAAM,GAAG,IAAI;IACjB;EACJ,CAAC;AACL,CAAC;AAED,SAASe,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module"}