{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst Transform = require('readable-stream').Transform;\nconst duplexify = require('duplexify');\n\n/* global FileReader */\nlet my;\nlet proxy;\nlet stream;\nlet isInitialized = false;\nfunction buildProxy() {\n  const proxy = new Transform();\n  proxy._write = function (chunk, encoding, next) {\n    my.sendSocketMessage({\n      data: chunk.buffer,\n      success: function () {\n        next();\n      },\n      fail: function () {\n        next(new Error());\n      }\n    });\n  };\n  proxy._flush = function socketEnd(done) {\n    my.closeSocket({\n      success: function () {\n        done();\n      }\n    });\n  };\n  return proxy;\n}\nfunction setDefaultOpts(opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost';\n  }\n  if (!opts.path) {\n    opts.path = '/';\n  }\n  if (!opts.wsOptions) {\n    opts.wsOptions = {};\n  }\n}\nfunction buildUrl(opts, client) {\n  const protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n  let url = protocol + '://' + opts.hostname + opts.path;\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n  }\n  if (typeof opts.transformWsUrl === 'function') {\n    url = opts.transformWsUrl(url, opts, client);\n  }\n  return url;\n}\nfunction bindEventHandler() {\n  if (isInitialized) return;\n  isInitialized = true;\n  my.onSocketOpen(function () {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  });\n  my.onSocketMessage(function (res) {\n    if (typeof res.data === 'string') {\n      const buffer = Buffer.from(res.data, 'base64');\n      proxy.push(buffer);\n    } else {\n      const reader = new FileReader();\n      reader.addEventListener('load', function () {\n        let data = reader.result;\n        if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n        proxy.push(data);\n      });\n      reader.readAsArrayBuffer(res.data);\n    }\n  });\n  my.onSocketClose(function () {\n    stream.end();\n    stream.destroy();\n  });\n  my.onSocketError(function (res) {\n    stream.destroy(res);\n  });\n}\nfunction buildStream(client, opts) {\n  opts.hostname = opts.hostname || opts.host;\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.');\n  }\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  setDefaultOpts(opts);\n  const url = buildUrl(opts, client);\n  my = opts.my;\n  my.connectSocket({\n    url: url,\n    protocols: websocketSubProtocol\n  });\n  proxy = buildProxy();\n  stream = duplexify.obj();\n  bindEventHandler();\n  return stream;\n}\nmodule.exports = buildStream;","map":{"version":3,"names":["Buffer","require","Transform","duplexify","my","proxy","stream","isInitialized","buildProxy","_write","chunk","encoding","next","sendSocketMessage","data","buffer","success","fail","Error","_flush","socketEnd","done","closeSocket","setDefaultOpts","opts","hostname","path","wsOptions","buildUrl","client","protocol","url","port","transformWsUrl","bindEventHandler","onSocketOpen","setReadable","setWritable","emit","onSocketMessage","res","from","push","reader","FileReader","addEventListener","result","ArrayBuffer","readAsArrayBuffer","onSocketClose","end","destroy","onSocketError","buildStream","host","websocketSubProtocol","protocolId","protocolVersion","connectSocket","protocols","obj","module","exports"],"sources":["C:/Documents/warehouse-dashboard/node_modules/mqtt/lib/connect/ali.js"],"sourcesContent":["'use strict'\r\n\r\nconst { Buffer } = require('buffer')\r\nconst Transform = require('readable-stream').Transform\r\nconst duplexify = require('duplexify')\r\n\r\n/* global FileReader */\r\nlet my\r\nlet proxy\r\nlet stream\r\nlet isInitialized = false\r\n\r\nfunction buildProxy () {\r\n  const proxy = new Transform()\r\n  proxy._write = function (chunk, encoding, next) {\r\n    my.sendSocketMessage({\r\n      data: chunk.buffer,\r\n      success: function () {\r\n        next()\r\n      },\r\n      fail: function () {\r\n        next(new Error())\r\n      }\r\n    })\r\n  }\r\n  proxy._flush = function socketEnd (done) {\r\n    my.closeSocket({\r\n      success: function () {\r\n        done()\r\n      }\r\n    })\r\n  }\r\n\r\n  return proxy\r\n}\r\n\r\nfunction setDefaultOpts (opts) {\r\n  if (!opts.hostname) {\r\n    opts.hostname = 'localhost'\r\n  }\r\n  if (!opts.path) {\r\n    opts.path = '/'\r\n  }\r\n\r\n  if (!opts.wsOptions) {\r\n    opts.wsOptions = {}\r\n  }\r\n}\r\n\r\nfunction buildUrl (opts, client) {\r\n  const protocol = opts.protocol === 'alis' ? 'wss' : 'ws'\r\n  let url = protocol + '://' + opts.hostname + opts.path\r\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\r\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\r\n  }\r\n  if (typeof (opts.transformWsUrl) === 'function') {\r\n    url = opts.transformWsUrl(url, opts, client)\r\n  }\r\n  return url\r\n}\r\n\r\nfunction bindEventHandler () {\r\n  if (isInitialized) return\r\n\r\n  isInitialized = true\r\n\r\n  my.onSocketOpen(function () {\r\n    stream.setReadable(proxy)\r\n    stream.setWritable(proxy)\r\n    stream.emit('connect')\r\n  })\r\n\r\n  my.onSocketMessage(function (res) {\r\n    if (typeof res.data === 'string') {\r\n      const buffer = Buffer.from(res.data, 'base64')\r\n      proxy.push(buffer)\r\n    } else {\r\n      const reader = new FileReader()\r\n      reader.addEventListener('load', function () {\r\n        let data = reader.result\r\n\r\n        if (data instanceof ArrayBuffer) data = Buffer.from(data)\r\n        else data = Buffer.from(data, 'utf8')\r\n        proxy.push(data)\r\n      })\r\n      reader.readAsArrayBuffer(res.data)\r\n    }\r\n  })\r\n\r\n  my.onSocketClose(function () {\r\n    stream.end()\r\n    stream.destroy()\r\n  })\r\n\r\n  my.onSocketError(function (res) {\r\n    stream.destroy(res)\r\n  })\r\n}\r\n\r\nfunction buildStream (client, opts) {\r\n  opts.hostname = opts.hostname || opts.host\r\n\r\n  if (!opts.hostname) {\r\n    throw new Error('Could not determine host. Specify host manually.')\r\n  }\r\n\r\n  const websocketSubProtocol =\r\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\r\n      ? 'mqttv3.1'\r\n      : 'mqtt'\r\n\r\n  setDefaultOpts(opts)\r\n\r\n  const url = buildUrl(opts, client)\r\n  my = opts.my\r\n  my.connectSocket({\r\n    url: url,\r\n    protocols: websocketSubProtocol\r\n  })\r\n\r\n  proxy = buildProxy()\r\n  stream = duplexify.obj()\r\n\r\n  bindEventHandler()\r\n\r\n  return stream\r\n}\r\n\r\nmodule.exports = buildStream\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}